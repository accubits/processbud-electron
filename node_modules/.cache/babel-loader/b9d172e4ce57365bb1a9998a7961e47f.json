{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/leela/OneDrive/Desktop/pb-angular-electron-main/21-06-2021/processbud/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\n\n/*!\n* rete v1.4.5-rc.1 \n* (c) 2020 Vitaliy Stoliarov \n* Released under the MIT license.\n*/\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nvar Component = function Component(name) {\n  _classCallCheck(this, Component);\n\n  _defineProperty(this, \"name\", void 0);\n\n  _defineProperty(this, \"data\", {});\n\n  _defineProperty(this, \"engine\", null);\n\n  this.name = name;\n};\n\nvar Node = /*#__PURE__*/function () {\n  function Node(name) {\n    _classCallCheck(this, Node);\n\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"position\", [0.0, 0.0]);\n\n    _defineProperty(this, \"inputs\", new Map());\n\n    _defineProperty(this, \"outputs\", new Map());\n\n    _defineProperty(this, \"controls\", new Map());\n\n    _defineProperty(this, \"data\", {});\n\n    _defineProperty(this, \"meta\", {});\n\n    this.name = name;\n    this.id = Node.incrementId();\n  }\n\n  _createClass(Node, [{\n    key: \"_add\",\n    value: function _add(list, item, prop) {\n      if (list.has(item.key)) throw new Error(\"Item with key '\".concat(item.key, \"' already been added to the node\"));\n      if (item[prop] !== null) throw new Error('Item has already been added to some node');\n      item[prop] = this;\n      list.set(item.key, item);\n    }\n  }, {\n    key: \"addControl\",\n    value: function addControl(control) {\n      this._add(this.controls, control, 'parent');\n\n      return this;\n    }\n  }, {\n    key: \"removeControl\",\n    value: function removeControl(control) {\n      control.parent = null;\n      this.controls[\"delete\"](control.key);\n    }\n  }, {\n    key: \"addInput\",\n    value: function addInput(input) {\n      this._add(this.inputs, input, 'node');\n\n      return this;\n    }\n  }, {\n    key: \"removeInput\",\n    value: function removeInput(input) {\n      input.removeConnections();\n      input.node = null;\n      this.inputs[\"delete\"](input.key);\n    }\n  }, {\n    key: \"addOutput\",\n    value: function addOutput(output) {\n      this._add(this.outputs, output, 'node');\n\n      return this;\n    }\n  }, {\n    key: \"removeOutput\",\n    value: function removeOutput(output) {\n      output.removeConnections();\n      output.node = null;\n      this.outputs[\"delete\"](output.key);\n    }\n  }, {\n    key: \"getConnections\",\n    value: function getConnections() {\n      var ios = [].concat(_toConsumableArray(this.inputs.values()), _toConsumableArray(this.outputs.values()));\n      var connections = ios.reduce(function (arr, io) {\n        return [].concat(_toConsumableArray(arr), _toConsumableArray(io.connections));\n      }, []);\n      return connections;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {}\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var reduceIO = function reduceIO(list) {\n        return Array.from(list).reduce(function (obj, _ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              key = _ref2[0],\n              io = _ref2[1];\n\n          obj[key] = io.toJSON();\n          return obj;\n        }, {});\n      };\n\n      return {\n        'id': this.id,\n        'data': this.data,\n        'inputs': reduceIO(this.inputs),\n        'outputs': reduceIO(this.outputs),\n        'position': this.position,\n        'name': this.name\n      };\n    }\n  }], [{\n    key: \"incrementId\",\n    value: function incrementId() {\n      if (!this.latestId) this.latestId = 1;else this.latestId++;\n      return this.latestId;\n    }\n  }, {\n    key: \"resetId\",\n    value: function resetId() {\n      this.latestId = 0;\n    }\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      var node = new Node(json.name);\n\n      var _json$position = _slicedToArray(json.position, 2),\n          x = _json$position[0],\n          y = _json$position[1];\n\n      node.id = json.id;\n      node.data = json.data;\n      node.position = [x, y];\n      node.name = json.name;\n      Node.latestId = Math.max(node.id, Node.latestId);\n      return node;\n    }\n  }]);\n\n  return Node;\n}();\n\n_defineProperty(Node, \"latestId\", 0);\n\nvar Component$1 = /*#__PURE__*/function (_ComponentWorker) {\n  _inherits(Component, _ComponentWorker);\n\n  function Component(name) {\n    var _this;\n\n    _classCallCheck(this, Component);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Component).call(this, name));\n\n    _defineProperty(_assertThisInitialized(_this), \"editor\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"data\", {});\n\n    return _this;\n  }\n\n  _createClass(Component, [{\n    key: \"build\",\n    value: function () {\n      var _build = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(node) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.builder(node);\n\n              case 2:\n                return _context.abrupt(\"return\", node);\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function build(_x) {\n        return _build.apply(this, arguments);\n      }\n\n      return build;\n    }()\n  }, {\n    key: \"createNode\",\n    value: function () {\n      var _createNode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var data,\n            node,\n            _args2 = arguments;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                data = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};\n                node = new Node(this.name);\n                node.data = data;\n                _context2.next = 5;\n                return this.build(node);\n\n              case 5:\n                return _context2.abrupt(\"return\", node);\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function createNode() {\n        return _createNode.apply(this, arguments);\n      }\n\n      return createNode;\n    }()\n  }]);\n\n  return Component;\n}(Component);\n\nvar Connection = /*#__PURE__*/function () {\n  function Connection(output, input) {\n    _classCallCheck(this, Connection);\n\n    _defineProperty(this, \"output\", void 0);\n\n    _defineProperty(this, \"input\", void 0);\n\n    _defineProperty(this, \"data\", {});\n\n    this.output = output;\n    this.input = input;\n    this.data = {};\n    this.input.addConnection(this);\n  }\n\n  _createClass(Connection, [{\n    key: \"remove\",\n    value: function remove() {\n      this.input.removeConnection(this);\n      this.output.removeConnection(this);\n    }\n  }]);\n\n  return Connection;\n}();\n\nvar Control = /*#__PURE__*/function () {\n  function Control(key) {\n    _classCallCheck(this, Control);\n\n    _defineProperty(this, \"key\", void 0);\n\n    _defineProperty(this, \"data\", {});\n\n    _defineProperty(this, \"parent\", null);\n\n    if (this.constructor === Control) throw new TypeError('Can not construct abstract class');\n    if (!key) throw new Error('The key parameter is missing in super() of Control ');\n    this.key = key;\n  }\n\n  _createClass(Control, [{\n    key: \"getNode\",\n    value: function getNode() {\n      if (this.parent === null) throw new Error('Control isn\\'t added to Node/Input');\n      if (this.parent instanceof Node) return this.parent;\n      if (!this.parent.node) throw new Error('Control hasn\\'t be added to Input or Node');\n      return this.parent.node;\n    }\n  }, {\n    key: \"getData\",\n    value: function getData(key) {\n      return this.getNode().data[key];\n    }\n  }, {\n    key: \"putData\",\n    value: function putData(key, data) {\n      this.getNode().data[key] = data;\n    }\n  }]);\n\n  return Control;\n}();\n\nvar Emitter = /*#__PURE__*/function () {\n  function Emitter(events) {\n    _classCallCheck(this, Emitter);\n\n    _defineProperty(this, \"events\", {});\n\n    _defineProperty(this, \"silent\", false);\n\n    this.events = events instanceof Emitter ? events.events : events.handlers;\n  }\n\n  _createClass(Emitter, [{\n    key: \"on\",\n    value: function on(names, handler) {\n      var _this = this;\n\n      var events = names instanceof Array ? names : names.split(' ');\n      events.forEach(function (name) {\n        if (!_this.events[name]) throw new Error(\"The event \".concat(name, \" does not exist\"));\n\n        _this.events[name].push(handler);\n      });\n      return this;\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(name) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (!(name in this.events)) throw new Error(\"The event \".concat(name, \" cannot be triggered\"));\n      return this.events[name].reduce(function (r, e) {\n        return e(params) !== false && r;\n      }, true); // return false if at least one event is false        \n    }\n  }, {\n    key: \"bind\",\n    value: function bind(name) {\n      if (this.events[name]) throw new Error(\"The event \".concat(name, \" is already bound\"));\n      this.events[name] = [];\n    }\n  }, {\n    key: \"exist\",\n    value: function exist(name) {\n      return Array.isArray(this.events[name]);\n    }\n  }]);\n\n  return Emitter;\n}();\n\nvar IO = /*#__PURE__*/function () {\n  function IO(key, name, socket, multiConns) {\n    _classCallCheck(this, IO);\n\n    _defineProperty(this, \"node\", null);\n\n    _defineProperty(this, \"multipleConnections\", void 0);\n\n    _defineProperty(this, \"connections\", []);\n\n    _defineProperty(this, \"key\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"socket\", void 0);\n\n    this.node = null;\n    this.multipleConnections = multiConns;\n    this.connections = [];\n    this.key = key;\n    this.name = name;\n    this.socket = socket;\n  }\n\n  _createClass(IO, [{\n    key: \"removeConnection\",\n    value: function removeConnection(connection) {\n      this.connections.splice(this.connections.indexOf(connection), 1);\n    }\n  }, {\n    key: \"removeConnections\",\n    value: function removeConnections() {\n      var _this = this;\n\n      this.connections.forEach(function (connection) {\n        return _this.removeConnection(connection);\n      });\n    }\n  }]);\n\n  return IO;\n}();\n\nvar Input = /*#__PURE__*/function (_IO) {\n  _inherits(Input, _IO);\n\n  function Input(key, title, socket) {\n    var _this;\n\n    var multiConns = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    _classCallCheck(this, Input);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Input).call(this, key, title, socket, multiConns));\n\n    _defineProperty(_assertThisInitialized(_this), \"control\", null);\n\n    return _this;\n  }\n\n  _createClass(Input, [{\n    key: \"hasConnection\",\n    value: function hasConnection() {\n      return this.connections.length > 0;\n    }\n  }, {\n    key: \"addConnection\",\n    value: function addConnection(connection) {\n      if (!this.multipleConnections && this.hasConnection()) throw new Error('Multiple connections not allowed');\n      this.connections.push(connection);\n    }\n  }, {\n    key: \"addControl\",\n    value: function addControl(control) {\n      this.control = control;\n      control.parent = this;\n    }\n  }, {\n    key: \"showControl\",\n    value: function showControl() {\n      return !this.hasConnection() && this.control !== null;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        'connections': this.connections.map(function (c) {\n          if (!c.output.node) throw new Error('Node not added to Output');\n          return {\n            node: c.output.node.id,\n            output: c.output.key,\n            data: c.data\n          };\n        })\n      };\n    }\n  }]);\n\n  return Input;\n}(IO);\n\nvar Validator = /*#__PURE__*/function () {\n  function Validator() {\n    _classCallCheck(this, Validator);\n  }\n\n  _createClass(Validator, null, [{\n    key: \"isValidData\",\n    value: function isValidData(data) {\n      return typeof data.id === 'string' && this.isValidId(data.id) && data.nodes instanceof Object && !(data.nodes instanceof Array);\n    }\n  }, {\n    key: \"isValidId\",\n    value: function isValidId(id) {\n      return /^[\\w-]{3,}@[0-9]+\\.[0-9]+\\.[0-9]+$/.test(id);\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(id, data) {\n      var id1 = id.split('@');\n      var id2 = data.id.split('@');\n      var msg = [];\n      if (!this.isValidData(data)) msg.push('Data is not suitable');\n      if (id !== data.id) msg.push('IDs not equal');\n      if (id1[0] !== id2[0]) msg.push('Names don\\'t match');\n      if (id1[1] !== id2[1]) msg.push('Versions don\\'t match');\n      return {\n        success: Boolean(!msg.length),\n        msg: msg.join('. ')\n      };\n    }\n  }]);\n\n  return Validator;\n}();\n\nvar Context = /*#__PURE__*/function (_Emitter) {\n  _inherits(Context, _Emitter);\n\n  function Context(id, events) {\n    var _this;\n\n    _classCallCheck(this, Context);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Context).call(this, events));\n\n    _defineProperty(_assertThisInitialized(_this), \"id\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"plugins\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"components\", void 0);\n\n    if (!Validator.isValidId(id)) throw new Error('ID should be valid to name@0.1.0 format');\n    _this.id = id;\n    _this.plugins = new Map();\n    _this.components = new Map();\n    return _this;\n  }\n\n  _createClass(Context, [{\n    key: \"use\",\n    value: function use(plugin, options) {\n      if (plugin.name && this.plugins.has(plugin.name)) throw new Error(\"Plugin \".concat(plugin.name, \" already in use\"));\n      plugin.install(this, options || {});\n      this.plugins.set(plugin.name, options);\n    }\n  }, {\n    key: \"register\",\n    value: function register(component) {\n      if (this.components.has(component.name)) throw new Error(\"Component \".concat(component.name, \" already registered\"));\n      this.components.set(component.name, component);\n      this.trigger('componentregister', component);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.trigger('destroy');\n    }\n  }]);\n\n  return Context;\n}(Emitter);\n\nfunction listenWindow(event, handler) {\n  window.addEventListener(event, handler);\n  return function () {\n    window.removeEventListener(event, handler);\n  };\n}\n\nvar Drag = /*#__PURE__*/function () {\n  function Drag(el) {\n    var onTranslate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (_x, _y, _e) {};\n    var onStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (_e) {};\n    var onDrag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (_e) {};\n\n    _classCallCheck(this, Drag);\n\n    this.onTranslate = onTranslate;\n    this.onStart = onStart;\n    this.onDrag = onDrag;\n\n    _defineProperty(this, \"pointerStart\", void 0);\n\n    _defineProperty(this, \"el\", void 0);\n\n    _defineProperty(this, \"destroy\", void 0);\n\n    this.pointerStart = null;\n    this.el = el;\n    this.el.style.touchAction = 'none';\n    this.el.addEventListener('pointerdown', this.down.bind(this));\n    var destroyMove = listenWindow('pointermove', this.move.bind(this));\n    var destroyUp = listenWindow('pointerup', this.up.bind(this));\n\n    this.destroy = function () {\n      destroyMove();\n      destroyUp();\n    };\n  }\n\n  _createClass(Drag, [{\n    key: \"down\",\n    value: function down(e) {\n      if (e.pointerType === 'mouse' && e.button !== 0) return;\n      e.stopPropagation();\n      this.pointerStart = [e.pageX, e.pageY];\n      this.onStart(e);\n    }\n  }, {\n    key: \"move\",\n    value: function move(e) {\n      if (!this.pointerStart) return;\n      e.preventDefault();\n      var _ref = [e.pageX, e.pageY],\n          x = _ref[0],\n          y = _ref[1];\n      var delta = [x - this.pointerStart[0], y - this.pointerStart[1]];\n      var zoom = this.el.getBoundingClientRect().width / this.el.offsetWidth;\n      this.onTranslate(delta[0] / zoom, delta[1] / zoom, e);\n    }\n  }, {\n    key: \"up\",\n    value: function up(e) {\n      if (!this.pointerStart) return;\n      this.pointerStart = null;\n      this.onDrag(e);\n    }\n  }]);\n\n  return Drag;\n}();\n\nvar Zoom = /*#__PURE__*/function () {\n  function Zoom(container, el, intensity, onzoom) {\n    _classCallCheck(this, Zoom);\n\n    _defineProperty(this, \"el\", void 0);\n\n    _defineProperty(this, \"intensity\", void 0);\n\n    _defineProperty(this, \"onzoom\", void 0);\n\n    _defineProperty(this, \"previous\", null);\n\n    _defineProperty(this, \"pointers\", []);\n\n    _defineProperty(this, \"destroy\", void 0);\n\n    this.el = el;\n    this.intensity = intensity;\n    this.onzoom = onzoom;\n    container.addEventListener('wheel', this.wheel.bind(this));\n    container.addEventListener('pointerdown', this.down.bind(this));\n    container.addEventListener('dblclick', this.dblclick.bind(this));\n    var destroyMove = listenWindow('pointermove', this.move.bind(this));\n    var destroyUp = listenWindow('pointerup', this.end.bind(this));\n    var destroyCancel = listenWindow('pointercancel', this.end.bind(this));\n\n    this.destroy = function () {\n      destroyMove();\n      destroyUp();\n      destroyCancel();\n    };\n  }\n\n  _createClass(Zoom, [{\n    key: \"wheel\",\n    value: function wheel(e) {\n      e.preventDefault();\n      var rect = this.el.getBoundingClientRect();\n      var wheelDelta = e.wheelDelta;\n      var delta = (wheelDelta ? wheelDelta / 120 : -e.deltaY / 3) * this.intensity;\n      var ox = (rect.left - e.clientX) * delta;\n      var oy = (rect.top - e.clientY) * delta;\n      this.onzoom(delta, ox, oy, 'wheel');\n    }\n  }, {\n    key: \"touches\",\n    value: function touches() {\n      var e = {\n        touches: this.pointers\n      };\n      var _ref = [e.touches[0].clientX, e.touches[0].clientY],\n          x1 = _ref[0],\n          y1 = _ref[1];\n      var _ref2 = [e.touches[1].clientX, e.touches[1].clientY],\n          x2 = _ref2[0],\n          y2 = _ref2[1];\n      var distance = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n      return {\n        cx: (x1 + x2) / 2,\n        cy: (y1 + y2) / 2,\n        distance: distance\n      };\n    }\n  }, {\n    key: \"down\",\n    value: function down(e) {\n      this.pointers.push(e);\n    }\n  }, {\n    key: \"move\",\n    value: function move(e) {\n      this.pointers = this.pointers.map(function (p) {\n        return p.pointerId === e.pointerId ? e : p;\n      });\n      if (!this.translating) return;\n      var rect = this.el.getBoundingClientRect();\n\n      var _this$touches = this.touches(),\n          cx = _this$touches.cx,\n          cy = _this$touches.cy,\n          distance = _this$touches.distance;\n\n      if (this.previous !== null) {\n        var delta = distance / this.previous.distance - 1;\n        var ox = (rect.left - cx) * delta;\n        var oy = (rect.top - cy) * delta;\n        this.onzoom(delta, ox - (this.previous.cx - cx), oy - (this.previous.cy - cy), 'touch');\n      }\n\n      this.previous = {\n        cx: cx,\n        cy: cy,\n        distance: distance\n      };\n    }\n  }, {\n    key: \"end\",\n    value: function end(e) {\n      this.previous = null;\n      this.pointers = this.pointers.filter(function (p) {\n        return p.pointerId !== e.pointerId;\n      });\n    }\n  }, {\n    key: \"dblclick\",\n    value: function dblclick(e) {\n      e.preventDefault();\n      var rect = this.el.getBoundingClientRect();\n      var delta = 4 * this.intensity;\n      var ox = (rect.left - e.clientX) * delta;\n      var oy = (rect.top - e.clientY) * delta;\n      this.onzoom(delta, ox, oy, 'dblclick');\n    }\n  }, {\n    key: \"translating\",\n    get: function get() {\n      // is translating while zoom (works on multitouch)\n      return this.pointers.length >= 2;\n    }\n  }]);\n\n  return Zoom;\n}();\n\nvar Area = /*#__PURE__*/function (_Emitter) {\n  _inherits(Area, _Emitter);\n\n  function Area(container, emitter) {\n    var _this;\n\n    _classCallCheck(this, Area);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Area).call(this, emitter));\n\n    _defineProperty(_assertThisInitialized(_this), \"el\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"container\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"transform\", {\n      k: 1,\n      x: 0,\n      y: 0\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"mouse\", {\n      x: 0,\n      y: 0\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_startPosition\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"_zoom\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_drag\", void 0);\n\n    var el = _this.el = document.createElement('div');\n    _this.container = container;\n    el.style.transformOrigin = '0 0';\n    _this._zoom = new Zoom(container, el, 0.1, _this.onZoom.bind(_assertThisInitialized(_this)));\n    _this._drag = new Drag(container, _this.onTranslate.bind(_assertThisInitialized(_this)), _this.onStart.bind(_assertThisInitialized(_this)));\n    emitter.on('destroy', function () {\n      _this._zoom.destroy();\n\n      _this._drag.destroy();\n    });\n\n    _this.container.addEventListener('pointermove', _this.pointermove.bind(_assertThisInitialized(_this)));\n\n    _this.update();\n\n    return _this;\n  }\n\n  _createClass(Area, [{\n    key: \"update\",\n    value: function update() {\n      var t = this.transform;\n      this.el.style.transform = \"translate(\".concat(t.x, \"px, \").concat(t.y, \"px) scale(\").concat(t.k, \")\");\n    }\n  }, {\n    key: \"pointermove\",\n    value: function pointermove(e) {\n      var clientX = e.clientX,\n          clientY = e.clientY;\n      var rect = this.el.getBoundingClientRect();\n      var x = clientX - rect.left;\n      var y = clientY - rect.top;\n      var k = this.transform.k;\n      this.mouse = {\n        x: x / k,\n        y: y / k\n      };\n      this.trigger('mousemove', _objectSpread({}, this.mouse)); // TODO rename on `pointermove`\n    }\n  }, {\n    key: \"onStart\",\n    value: function onStart() {\n      this._startPosition = _objectSpread({}, this.transform);\n    }\n  }, {\n    key: \"onTranslate\",\n    value: function onTranslate(dx, dy) {\n      if (this._zoom.translating) return; // lock translation while zoom on multitouch\n\n      if (this._startPosition) this.translate(this._startPosition.x + dx, this._startPosition.y + dy);\n    }\n  }, {\n    key: \"onZoom\",\n    value: function onZoom(delta, ox, oy, source) {\n      this.zoom(this.transform.k * (1 + delta), ox, oy, source);\n      this.update();\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(x, y) {\n      var params = {\n        transform: this.transform,\n        x: x,\n        y: y\n      };\n      if (!this.trigger('translate', params)) return;\n      this.transform.x = params.x;\n      this.transform.y = params.y;\n      this.update();\n      this.trigger('translated');\n    }\n  }, {\n    key: \"zoom\",\n    value: function zoom(_zoom) {\n      var ox = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var oy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var source = arguments.length > 3 ? arguments[3] : undefined;\n      var k = this.transform.k;\n      var params = {\n        transform: this.transform,\n        zoom: _zoom,\n        source: source\n      };\n      if (!this.trigger('zoom', params)) return;\n      var d = (k - params.zoom) / (k - _zoom || 1);\n      this.transform.k = params.zoom || 1;\n      this.transform.x += ox * d;\n      this.transform.y += oy * d;\n      this.update();\n      this.trigger('zoomed', {\n        source: source\n      });\n    }\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(el) {\n      this.el.appendChild(el);\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(el) {\n      this.el.removeChild(el);\n    }\n  }]);\n\n  return Area;\n}(Emitter);\n\nvar ConnectionView = /*#__PURE__*/function (_Emitter) {\n  _inherits(ConnectionView, _Emitter);\n\n  function ConnectionView(connection, inputNode, outputNode, emitter) {\n    var _this;\n\n    _classCallCheck(this, ConnectionView);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ConnectionView).call(this, emitter));\n\n    _defineProperty(_assertThisInitialized(_this), \"connection\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"inputNode\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"outputNode\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"el\", void 0);\n\n    _this.connection = connection;\n    _this.inputNode = inputNode;\n    _this.outputNode = outputNode;\n    _this.el = document.createElement('div');\n    _this.el.style.position = 'absolute';\n    _this.el.style.zIndex = '-1';\n\n    _this.trigger('renderconnection', {\n      el: _this.el,\n      connection: _this.connection,\n      points: _this.getPoints()\n    });\n\n    return _this;\n  }\n\n  _createClass(ConnectionView, [{\n    key: \"getPoints\",\n    value: function getPoints() {\n      var _this$outputNode$getS = this.outputNode.getSocketPosition(this.connection.output),\n          _this$outputNode$getS2 = _slicedToArray(_this$outputNode$getS, 2),\n          x1 = _this$outputNode$getS2[0],\n          y1 = _this$outputNode$getS2[1];\n\n      var _this$inputNode$getSo = this.inputNode.getSocketPosition(this.connection.input),\n          _this$inputNode$getSo2 = _slicedToArray(_this$inputNode$getSo, 2),\n          x2 = _this$inputNode$getSo2[0],\n          y2 = _this$inputNode$getSo2[1];\n\n      return [x1, y1, x2, y2];\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.trigger('updateconnection', {\n        el: this.el,\n        connection: this.connection,\n        points: this.getPoints()\n      });\n    }\n  }]);\n\n  return ConnectionView;\n}(Emitter);\n\nvar ControlView = /*#__PURE__*/function (_Emitter) {\n  _inherits(ControlView, _Emitter);\n\n  function ControlView(el, control, emitter) {\n    var _this;\n\n    _classCallCheck(this, ControlView);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ControlView).call(this, emitter));\n\n    _this.trigger('rendercontrol', {\n      el: el,\n      control: control\n    });\n\n    return _this;\n  }\n\n  return ControlView;\n}(Emitter);\n\nvar SocketView = /*#__PURE__*/function (_Emitter) {\n  _inherits(SocketView, _Emitter);\n\n  function SocketView(el, type, io, node, emitter) {\n    var _this$trigger;\n\n    var _this;\n\n    _classCallCheck(this, SocketView);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SocketView).call(this, emitter));\n\n    _defineProperty(_assertThisInitialized(_this), \"el\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"type\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"io\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"node\", void 0);\n\n    _this.el = el;\n    _this.type = type;\n    _this.io = io;\n    _this.node = node;\n\n    _this.trigger('rendersocket', (_this$trigger = {\n      el: el\n    }, _defineProperty(_this$trigger, type, _this.io), _defineProperty(_this$trigger, \"socket\", io.socket), _this$trigger));\n\n    return _this;\n  }\n\n  _createClass(SocketView, [{\n    key: \"getPosition\",\n    value: function getPosition(_ref) {\n      var position = _ref.position;\n      var el = this.el;\n      return [position[0] + el.offsetLeft + el.offsetWidth / 2, position[1] + el.offsetTop + el.offsetHeight / 2];\n    }\n  }]);\n\n  return SocketView;\n}(Emitter);\n\nvar NodeView = /*#__PURE__*/function (_Emitter) {\n  _inherits(NodeView, _Emitter);\n\n  function NodeView(node, component, emitter) {\n    var _this;\n\n    _classCallCheck(this, NodeView);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeView).call(this, emitter));\n\n    _defineProperty(_assertThisInitialized(_this), \"node\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"component\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"sockets\", new Map());\n\n    _defineProperty(_assertThisInitialized(_this), \"controls\", new Map());\n\n    _defineProperty(_assertThisInitialized(_this), \"el\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_startPosition\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"_drag\", void 0);\n\n    _this.node = node;\n    _this.component = component;\n    _this.el = document.createElement('div');\n    _this.el.style.position = 'absolute';\n\n    _this.el.addEventListener('contextmenu', function (e) {\n      return _this.trigger('contextmenu', {\n        e: e,\n        node: _this.node\n      });\n    });\n\n    _this._drag = new Drag(_this.el, _this.onTranslate.bind(_assertThisInitialized(_this)), _this.onSelect.bind(_assertThisInitialized(_this)), function () {\n      _this.trigger('nodedraged', node);\n\n      _this.trigger('nodedragged', node);\n    });\n\n    _this.trigger('rendernode', {\n      el: _this.el,\n      node: node,\n      component: component.data,\n      bindSocket: _this.bindSocket.bind(_assertThisInitialized(_this)),\n      bindControl: _this.bindControl.bind(_assertThisInitialized(_this))\n    });\n\n    _this.update();\n\n    return _this;\n  }\n\n  _createClass(NodeView, [{\n    key: \"clearSockets\",\n    value: function clearSockets() {\n      var _this2 = this;\n\n      var ios = [].concat(_toConsumableArray(this.node.inputs.values()), _toConsumableArray(this.node.outputs.values()));\n      this.sockets.forEach(function (s) {\n        if (!ios.includes(s.io)) _this2.sockets[\"delete\"](s.io);\n      });\n    }\n  }, {\n    key: \"bindSocket\",\n    value: function bindSocket(el, type, io) {\n      this.clearSockets();\n      this.sockets.set(io, new SocketView(el, type, io, this.node, this));\n    }\n  }, {\n    key: \"bindControl\",\n    value: function bindControl(el, control) {\n      this.controls.set(control, new ControlView(el, control, this));\n    }\n  }, {\n    key: \"getSocketPosition\",\n    value: function getSocketPosition(io) {\n      var socket = this.sockets.get(io);\n      if (!socket) throw new Error(\"Socket not found for \".concat(io.name, \" with key \").concat(io.key));\n      return socket.getPosition(this.node);\n    }\n  }, {\n    key: \"onSelect\",\n    value: function onSelect(e) {\n      var payload = {\n        node: this.node,\n        accumulate: e.ctrlKey,\n        e: e\n      };\n      this.onStart();\n      this.trigger('multiselectnode', payload);\n      this.trigger('selectnode', payload);\n    }\n  }, {\n    key: \"onStart\",\n    value: function onStart() {\n      this._startPosition = _toConsumableArray(this.node.position);\n    }\n  }, {\n    key: \"onTranslate\",\n    value: function onTranslate(dx, dy) {\n      this.trigger('translatenode', {\n        node: this.node,\n        dx: dx,\n        dy: dy\n      });\n    }\n  }, {\n    key: \"onDrag\",\n    value: function onDrag(dx, dy) {\n      var x = this._startPosition[0] + dx;\n      var y = this._startPosition[1] + dy;\n      this.translate(x, y);\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(x, y) {\n      var node = this.node;\n      var params = {\n        node: node,\n        x: x,\n        y: y\n      };\n      if (!this.trigger('nodetranslate', params)) return;\n\n      var _node$position = _slicedToArray(node.position, 2),\n          px = _node$position[0],\n          py = _node$position[1];\n\n      var prev = [px, py];\n      node.position[0] = params.x;\n      node.position[1] = params.y;\n      this.update();\n      this.trigger('nodetranslated', {\n        node: node,\n        prev: prev\n      });\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var _this$node$position = _slicedToArray(this.node.position, 2),\n          x = _this$node$position[0],\n          y = _this$node$position[1];\n\n      this.el.style.transform = \"translate(\".concat(x, \"px, \").concat(y, \"px)\");\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {}\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._drag.destroy();\n    }\n  }]);\n\n  return NodeView;\n}(Emitter);\n\nvar EditorView = /*#__PURE__*/function (_Emitter) {\n  _inherits(EditorView, _Emitter);\n\n  function EditorView(container, components, emitter) {\n    var _this;\n\n    _classCallCheck(this, EditorView);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(EditorView).call(this, emitter));\n\n    _defineProperty(_assertThisInitialized(_this), \"container\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"components\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"nodes\", new Map());\n\n    _defineProperty(_assertThisInitialized(_this), \"connections\", new Map());\n\n    _defineProperty(_assertThisInitialized(_this), \"area\", void 0);\n\n    _this.container = container;\n    _this.components = components;\n    _this.container.style.overflow = 'hidden';\n\n    _this.container.addEventListener('click', _this.click.bind(_assertThisInitialized(_this)));\n\n    _this.container.addEventListener('contextmenu', function (e) {\n      return _this.trigger('contextmenu', {\n        e: e,\n        view: _assertThisInitialized(_this)\n      });\n    });\n\n    emitter.on('destroy', listenWindow('resize', _this.resize.bind(_assertThisInitialized(_this))));\n    emitter.on('destroy', function () {\n      return _this.nodes.forEach(function (view) {\n        return view.destroy();\n      });\n    });\n\n    _this.on('nodetranslated', _this.updateConnections.bind(_assertThisInitialized(_this)));\n\n    _this.area = new Area(container, _assertThisInitialized(_this));\n\n    _this.container.appendChild(_this.area.el);\n\n    return _this;\n  }\n\n  _createClass(EditorView, [{\n    key: \"addNode\",\n    value: function addNode(node) {\n      var component = this.components.get(node.name);\n      if (!component) throw new Error(\"Component \".concat(node.name, \" not found\"));\n      var nodeView = new NodeView(node, component, this);\n      this.nodes.set(node, nodeView);\n      this.area.appendChild(nodeView.el);\n    }\n  }, {\n    key: \"removeNode\",\n    value: function removeNode(node) {\n      var nodeView = this.nodes.get(node);\n      this.nodes[\"delete\"](node);\n\n      if (nodeView) {\n        this.area.removeChild(nodeView.el);\n        nodeView.destroy();\n      }\n    }\n  }, {\n    key: \"addConnection\",\n    value: function addConnection(connection) {\n      if (!connection.input.node || !connection.output.node) throw new Error('Connection input or output not added to node');\n      var viewInput = this.nodes.get(connection.input.node);\n      var viewOutput = this.nodes.get(connection.output.node);\n      if (!viewInput || !viewOutput) throw new Error('View node not found for input or output');\n      var connView = new ConnectionView(connection, viewInput, viewOutput, this);\n      this.connections.set(connection, connView);\n      this.area.appendChild(connView.el);\n    }\n  }, {\n    key: \"removeConnection\",\n    value: function removeConnection(connection) {\n      var connView = this.connections.get(connection);\n      this.connections[\"delete\"](connection);\n      if (connView) this.area.removeChild(connView.el);\n    }\n  }, {\n    key: \"updateConnections\",\n    value: function updateConnections(_ref) {\n      var _this2 = this;\n\n      var node = _ref.node;\n      node.getConnections().forEach(function (conn) {\n        var connView = _this2.connections.get(conn);\n\n        if (!connView) throw new Error('Connection view not found');\n        connView.update();\n      });\n    }\n  }, {\n    key: \"resize\",\n    value: function resize() {\n      var container = this.container;\n      if (!container.parentElement) throw new Error('Container doesn\\'t have parent element');\n      var width = container.parentElement.clientWidth;\n      var height = container.parentElement.clientHeight;\n      container.style.width = width + 'px';\n      container.style.height = height + 'px';\n    }\n  }, {\n    key: \"click\",\n    value: function click(e) {\n      var container = this.container;\n      if (container !== e.target) return;\n      if (!this.trigger('click', {\n        e: e,\n        container: container\n      })) return;\n    }\n  }]);\n\n  return EditorView;\n}(Emitter);\n\nvar Selected = /*#__PURE__*/function () {\n  function Selected() {\n    _classCallCheck(this, Selected);\n\n    _defineProperty(this, \"list\", []);\n  }\n\n  _createClass(Selected, [{\n    key: \"add\",\n    value: function add(item) {\n      var accumulate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (!accumulate) this.list = [item];else if (!this.contains(item)) this.list.push(item);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.list = [];\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(item) {\n      this.list.splice(this.list.indexOf(item), 1);\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(item) {\n      return this.list.indexOf(item) !== -1;\n    }\n  }, {\n    key: \"each\",\n    value: function each(callback) {\n      this.list.forEach(callback);\n    }\n  }]);\n\n  return Selected;\n}();\n\nvar Events = function Events(handlers) {\n  _classCallCheck(this, Events);\n\n  _defineProperty(this, \"handlers\", void 0);\n\n  this.handlers = _objectSpread({\n    warn: [console.warn],\n    error: [console.error],\n    componentregister: [],\n    destroy: []\n  }, handlers);\n};\n\nvar EditorEvents = /*#__PURE__*/function (_Events) {\n  _inherits(EditorEvents, _Events);\n\n  function EditorEvents() {\n    _classCallCheck(this, EditorEvents);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(EditorEvents).call(this, {\n      nodecreate: [],\n      nodecreated: [],\n      noderemove: [],\n      noderemoved: [],\n      connectioncreate: [],\n      connectioncreated: [],\n      connectionremove: [],\n      connectionremoved: [],\n      translatenode: [],\n      nodetranslate: [],\n      nodetranslated: [],\n      nodedraged: [],\n      nodedragged: [],\n      selectnode: [],\n      multiselectnode: [],\n      nodeselect: [],\n      nodeselected: [],\n      rendernode: [],\n      rendersocket: [],\n      rendercontrol: [],\n      renderconnection: [],\n      updateconnection: [],\n      keydown: [],\n      keyup: [],\n      translate: [],\n      translated: [],\n      zoom: [],\n      zoomed: [],\n      click: [],\n      mousemove: [],\n      contextmenu: [],\n      \"import\": [],\n      \"export\": [],\n      process: [],\n      clear: []\n    }));\n  }\n\n  return EditorEvents;\n}(Events);\n\nvar NodeEditor = /*#__PURE__*/function (_Context) {\n  _inherits(NodeEditor, _Context);\n\n  function NodeEditor(id, container) {\n    var _this;\n\n    _classCallCheck(this, NodeEditor);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeEditor).call(this, id, new EditorEvents()));\n\n    _defineProperty(_assertThisInitialized(_this), \"nodes\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"selected\", new Selected());\n\n    _defineProperty(_assertThisInitialized(_this), \"view\", void 0);\n\n    _this.view = new EditorView(container, _this.components, _assertThisInitialized(_this));\n\n    _this.on('destroy', listenWindow('keydown', function (e) {\n      return _this.trigger('keydown', e);\n    }));\n\n    _this.on('destroy', listenWindow('keyup', function (e) {\n      return _this.trigger('keyup', e);\n    }));\n\n    _this.on('selectnode', function (_ref) {\n      var node = _ref.node,\n          accumulate = _ref.accumulate;\n      return _this.selectNode(node, accumulate);\n    });\n\n    _this.on('nodeselected', function () {\n      return _this.selected.each(function (n) {\n        var nodeView = _this.view.nodes.get(n);\n\n        nodeView && nodeView.onStart();\n      });\n    });\n\n    _this.on('translatenode', function (_ref2) {\n      var dx = _ref2.dx,\n          dy = _ref2.dy;\n      return _this.selected.each(function (n) {\n        var nodeView = _this.view.nodes.get(n);\n\n        nodeView && nodeView.onDrag(dx, dy);\n      });\n    });\n\n    return _this;\n  }\n\n  _createClass(NodeEditor, [{\n    key: \"addNode\",\n    value: function addNode(node) {\n      if (!this.trigger('nodecreate', node)) return;\n      this.nodes.push(node);\n      this.view.addNode(node);\n      this.trigger('nodecreated', node);\n    }\n  }, {\n    key: \"removeNode\",\n    value: function removeNode(node) {\n      var _this2 = this;\n\n      if (!this.trigger('noderemove', node)) return;\n      node.getConnections().forEach(function (c) {\n        return _this2.removeConnection(c);\n      });\n      this.nodes.splice(this.nodes.indexOf(node), 1);\n      this.view.removeNode(node);\n      this.trigger('noderemoved', node);\n    }\n  }, {\n    key: \"connect\",\n    value: function connect(output, input) {\n      var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (!this.trigger('connectioncreate', {\n        output: output,\n        input: input\n      })) return;\n\n      try {\n        var connection = output.connectTo(input);\n        connection.data = data;\n        this.view.addConnection(connection);\n        this.trigger('connectioncreated', connection);\n      } catch (e) {\n        this.trigger('warn', e);\n      }\n    }\n  }, {\n    key: \"removeConnection\",\n    value: function removeConnection(connection) {\n      if (!this.trigger('connectionremove', connection)) return;\n      this.view.removeConnection(connection);\n      connection.remove();\n      this.trigger('connectionremoved', connection);\n    }\n  }, {\n    key: \"selectNode\",\n    value: function selectNode(node) {\n      var accumulate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (this.nodes.indexOf(node) === -1) throw new Error('Node not exist in list');\n      if (!this.trigger('nodeselect', node)) return;\n      this.selected.add(node, accumulate);\n      this.trigger('nodeselected', node);\n    }\n  }, {\n    key: \"getComponent\",\n    value: function getComponent(name) {\n      var component = this.components.get(name);\n      if (!component) throw \"Component \".concat(name, \" not found\");\n      return component;\n    }\n  }, {\n    key: \"register\",\n    value: function register(component) {\n      _get(_getPrototypeOf(NodeEditor.prototype), \"register\", this).call(this, component);\n\n      component.editor = this;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this3 = this;\n\n      _toConsumableArray(this.nodes).forEach(function (node) {\n        return _this3.removeNode(node);\n      });\n\n      this.trigger('clear');\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var data = {\n        id: this.id,\n        nodes: {}\n      };\n      this.nodes.forEach(function (node) {\n        return data.nodes[node.id] = node.toJSON();\n      });\n      this.trigger('export', data);\n      return data;\n    }\n  }, {\n    key: \"beforeImport\",\n    value: function beforeImport(json) {\n      var checking = Validator.validate(this.id, json);\n\n      if (!checking.success) {\n        this.trigger('warn', checking.msg);\n        return false;\n      }\n\n      this.silent = true;\n      this.clear();\n      this.trigger('import', json);\n      return true;\n    }\n  }, {\n    key: \"afterImport\",\n    value: function afterImport() {\n      this.silent = false;\n      return true;\n    }\n  }, {\n    key: \"fromJSON\",\n    value: function () {\n      var _fromJSON = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(json) {\n        var _this4 = this;\n\n        var nodes;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this.beforeImport(json)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", false);\n\n              case 2:\n                nodes = {};\n                _context2.prev = 3;\n                _context2.next = 6;\n                return Promise.all(Object.keys(json.nodes).map( /*#__PURE__*/function () {\n                  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(id) {\n                    var node, component;\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            node = json.nodes[id];\n                            component = _this4.getComponent(node.name);\n                            _context.next = 4;\n                            return component.build(Node.fromJSON(node));\n\n                          case 4:\n                            nodes[id] = _context.sent;\n\n                            _this4.addNode(nodes[id]);\n\n                          case 6:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n\n                  return function (_x2) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }()));\n\n              case 6:\n                Object.keys(json.nodes).forEach(function (id) {\n                  var jsonNode = json.nodes[id];\n                  var node = nodes[id];\n                  Object.keys(jsonNode.outputs).forEach(function (key) {\n                    var outputJson = jsonNode.outputs[key];\n                    outputJson.connections.forEach(function (jsonConnection) {\n                      var nodeId = jsonConnection.node;\n                      var data = jsonConnection.data;\n                      var targetOutput = node.outputs.get(key);\n                      var targetInput = nodes[nodeId].inputs.get(jsonConnection.input);\n\n                      if (!targetOutput || !targetInput) {\n                        return _this4.trigger('error', \"IO not found for node \".concat(node.id));\n                      }\n\n                      _this4.connect(targetOutput, targetInput, data);\n                    });\n                  });\n                });\n                _context2.next = 13;\n                break;\n\n              case 9:\n                _context2.prev = 9;\n                _context2.t0 = _context2[\"catch\"](3);\n                this.trigger('warn', _context2.t0);\n                return _context2.abrupt(\"return\", !this.afterImport());\n\n              case 13:\n                return _context2.abrupt(\"return\", this.afterImport());\n\n              case 14:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[3, 9]]);\n      }));\n\n      function fromJSON(_x) {\n        return _fromJSON.apply(this, arguments);\n      }\n\n      return fromJSON;\n    }()\n  }]);\n\n  return NodeEditor;\n}(Context);\n\nvar Output = /*#__PURE__*/function (_IO) {\n  _inherits(Output, _IO);\n\n  function Output(key, title, socket) {\n    var multiConns = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    _classCallCheck(this, Output);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Output).call(this, key, title, socket, multiConns));\n  }\n\n  _createClass(Output, [{\n    key: \"hasConnection\",\n    value: function hasConnection() {\n      return this.connections.length > 0;\n    }\n  }, {\n    key: \"connectTo\",\n    value: function connectTo(input) {\n      if (!this.socket.compatibleWith(input.socket)) throw new Error('Sockets not compatible');\n      if (!input.multipleConnections && input.hasConnection()) throw new Error('Input already has one connection');\n      if (!this.multipleConnections && this.hasConnection()) throw new Error('Output already has one connection');\n      var connection = new Connection(this, input);\n      this.connections.push(connection);\n      return connection;\n    }\n  }, {\n    key: \"connectedTo\",\n    value: function connectedTo(input) {\n      return this.connections.some(function (item) {\n        return item.input === input;\n      });\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        'connections': this.connections.map(function (c) {\n          if (!c.input.node) throw new Error('Node not added to Input');\n          return {\n            node: c.input.node.id,\n            input: c.input.key,\n            data: c.data\n          };\n        })\n      };\n    }\n  }]);\n\n  return Output;\n}(IO);\n\nvar Socket = /*#__PURE__*/function () {\n  function Socket(name) {\n    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Socket);\n\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"data\", void 0);\n\n    _defineProperty(this, \"compatible\", []);\n\n    this.name = name;\n    this.data = data;\n    this.compatible = [];\n  }\n\n  _createClass(Socket, [{\n    key: \"combineWith\",\n    value: function combineWith(socket) {\n      this.compatible.push(socket);\n    }\n  }, {\n    key: \"compatibleWith\",\n    value: function compatibleWith(socket) {\n      return this === socket || this.compatible.includes(socket);\n    }\n  }]);\n\n  return Socket;\n}();\n\nfunction intersect(array1, array2) {\n  return array1.filter(function (value) {\n    return -1 !== array2.indexOf(value);\n  });\n}\n\nvar Recursion = /*#__PURE__*/function () {\n  function Recursion(nodes) {\n    _classCallCheck(this, Recursion);\n\n    _defineProperty(this, \"nodes\", void 0);\n\n    this.nodes = nodes;\n  }\n\n  _createClass(Recursion, [{\n    key: \"extractInputNodes\",\n    value: function extractInputNodes(node) {\n      var _this = this;\n\n      return Object.keys(node.inputs).reduce(function (acc, key) {\n        var connections = node.inputs[key].connections;\n        var nodesData = (connections || []).reduce(function (b, c) {\n          return [].concat(_toConsumableArray(b), [_this.nodes[c.node]]);\n        }, []);\n        return [].concat(_toConsumableArray(acc), _toConsumableArray(nodesData));\n      }, []);\n    }\n  }, {\n    key: \"findSelf\",\n    value: function findSelf(list, inputNodes) {\n      var inters = intersect(list, inputNodes);\n      if (inters.length) return inters[0];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = inputNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var node = _step.value;\n          var l = [node].concat(_toConsumableArray(list));\n          var inter = this.findSelf(l, this.extractInputNodes(node));\n          if (inter) return inter;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"detect\",\n    value: function detect() {\n      var _this2 = this;\n\n      var nodesArr = Object.keys(this.nodes).map(function (id) {\n        return _this2.nodes[id];\n      });\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = nodesArr[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var node = _step2.value;\n          var inters = this.findSelf([node], this.extractInputNodes(node));\n          if (inters) return inters;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  return Recursion;\n}();\n\nvar State = {\n  AVAILABLE: 0,\n  PROCESSED: 1,\n  ABORT: 2\n};\n\nvar EngineEvents = /*#__PURE__*/function (_Events) {\n  _inherits(EngineEvents, _Events);\n\n  function EngineEvents() {\n    _classCallCheck(this, EngineEvents);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(EngineEvents).call(this, {}));\n  }\n\n  return EngineEvents;\n}(Events);\n\nvar Engine = /*#__PURE__*/function (_Context) {\n  _inherits(Engine, _Context);\n\n  function Engine(id) {\n    var _this;\n\n    _classCallCheck(this, Engine);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Engine).call(this, id, new EngineEvents()));\n\n    _defineProperty(_assertThisInitialized(_this), \"args\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"data\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", State.AVAILABLE);\n\n    _defineProperty(_assertThisInitialized(_this), \"forwarded\", new Set());\n\n    _defineProperty(_assertThisInitialized(_this), \"onAbort\", function () {});\n\n    return _this;\n  }\n\n  _createClass(Engine, [{\n    key: \"clone\",\n    value: function clone() {\n      var engine = new Engine(this.id);\n      this.components.forEach(function (c) {\n        return engine.register(c);\n      });\n      return engine;\n    }\n  }, {\n    key: \"throwError\",\n    value: function () {\n      var _throwError = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(message) {\n        var data,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                data = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;\n                _context.next = 3;\n                return this.abort();\n\n              case 3:\n                this.trigger('error', {\n                  message: message,\n                  data: data\n                });\n                this.processDone();\n                return _context.abrupt(\"return\", 'error');\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function throwError(_x) {\n        return _throwError.apply(this, arguments);\n      }\n\n      return throwError;\n    }()\n  }, {\n    key: \"processStart\",\n    value: function processStart() {\n      if (this.state === State.AVAILABLE) {\n        this.state = State.PROCESSED;\n        return true;\n      }\n\n      if (this.state === State.ABORT) {\n        return false;\n      }\n\n      console.warn(\"The process is busy and has not been restarted.\\n                Use abort() to force it to complete\");\n      return false;\n    }\n  }, {\n    key: \"processDone\",\n    value: function processDone() {\n      var success = this.state !== State.ABORT;\n      this.state = State.AVAILABLE;\n\n      if (!success) {\n        this.onAbort();\n\n        this.onAbort = function () {};\n      }\n\n      return success;\n    }\n  }, {\n    key: \"abort\",\n    value: function () {\n      var _abort = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", new Promise(function (ret) {\n                  if (_this2.state === State.PROCESSED) {\n                    _this2.state = State.ABORT;\n                    _this2.onAbort = ret;\n                  } else if (_this2.state === State.ABORT) {\n                    _this2.onAbort();\n\n                    _this2.onAbort = ret;\n                  } else ret();\n                }));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function abort() {\n        return _abort.apply(this, arguments);\n      }\n\n      return abort;\n    }()\n  }, {\n    key: \"lock\",\n    value: function () {\n      var _lock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(node) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", new Promise(function (res) {\n                  node.unlockPool = node.unlockPool || [];\n                  if (node.busy && !node.outputData) node.unlockPool.push(res);else res();\n                  node.busy = true;\n                }));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function lock(_x2) {\n        return _lock.apply(this, arguments);\n      }\n\n      return lock;\n    }()\n  }, {\n    key: \"unlock\",\n    value: function unlock(node) {\n      node.unlockPool.forEach(function (a) {\n        return a();\n      });\n      node.unlockPool = [];\n      node.busy = false;\n    }\n  }, {\n    key: \"extractInputData\",\n    value: function () {\n      var _extractInputData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(node) {\n        var _this3 = this;\n\n        var obj, _i, _Object$keys, key, input, conns, connData;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                obj = {};\n                _i = 0, _Object$keys = Object.keys(node.inputs);\n\n              case 2:\n                if (!(_i < _Object$keys.length)) {\n                  _context5.next = 13;\n                  break;\n                }\n\n                key = _Object$keys[_i];\n                input = node.inputs[key];\n                conns = input.connections;\n                _context5.next = 8;\n                return Promise.all(conns.map( /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(c) {\n                    var prevNode, outputs;\n                    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                      while (1) {\n                        switch (_context4.prev = _context4.next) {\n                          case 0:\n                            prevNode = _this3.data.nodes[c.node];\n                            _context4.next = 3;\n                            return _this3.processNode(prevNode);\n\n                          case 3:\n                            outputs = _context4.sent;\n\n                            if (outputs) {\n                              _context4.next = 8;\n                              break;\n                            }\n\n                            _this3.abort();\n\n                            _context4.next = 9;\n                            break;\n\n                          case 8:\n                            return _context4.abrupt(\"return\", outputs[c.output]);\n\n                          case 9:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }\n                    }, _callee4);\n                  }));\n\n                  return function (_x4) {\n                    return _ref.apply(this, arguments);\n                  };\n                }()));\n\n              case 8:\n                connData = _context5.sent;\n                obj[key] = connData;\n\n              case 10:\n                _i++;\n                _context5.next = 2;\n                break;\n\n              case 13:\n                return _context5.abrupt(\"return\", obj);\n\n              case 14:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n\n      function extractInputData(_x3) {\n        return _extractInputData.apply(this, arguments);\n      }\n\n      return extractInputData;\n    }()\n  }, {\n    key: \"processWorker\",\n    value: function () {\n      var _processWorker = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(node) {\n        var inputData, component, outputData;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.extractInputData(node);\n\n              case 2:\n                inputData = _context6.sent;\n                component = this.components.get(node.name);\n                outputData = {};\n                _context6.prev = 5;\n                _context6.next = 8;\n                return component.worker.apply(component, [node, inputData, outputData].concat(_toConsumableArray(this.args)));\n\n              case 8:\n                _context6.next = 14;\n                break;\n\n              case 10:\n                _context6.prev = 10;\n                _context6.t0 = _context6[\"catch\"](5);\n                this.abort();\n                this.trigger('warn', _context6.t0);\n\n              case 14:\n                return _context6.abrupt(\"return\", outputData);\n\n              case 15:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[5, 10]]);\n      }));\n\n      function processWorker(_x5) {\n        return _processWorker.apply(this, arguments);\n      }\n\n      return processWorker;\n    }()\n  }, {\n    key: \"processNode\",\n    value: function () {\n      var _processNode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(node) {\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!(this.state === State.ABORT || !node)) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", null);\n\n              case 2:\n                _context7.next = 4;\n                return this.lock(node);\n\n              case 4:\n                if (node.outputData) {\n                  _context7.next = 8;\n                  break;\n                }\n\n                _context7.next = 7;\n                return this.processWorker(node);\n\n              case 7:\n                node.outputData = _context7.sent;\n\n              case 8:\n                this.unlock(node);\n                return _context7.abrupt(\"return\", node.outputData);\n\n              case 10:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function processNode(_x6) {\n        return _processNode.apply(this, arguments);\n      }\n\n      return processNode;\n    }()\n  }, {\n    key: \"forwardProcess\",\n    value: function () {\n      var _forwardProcess = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(node) {\n        var _this4 = this;\n\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (!(this.state === State.ABORT)) {\n                  _context10.next = 2;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", null);\n\n              case 2:\n                _context10.next = 4;\n                return Promise.all(Object.keys(node.outputs).map( /*#__PURE__*/function () {\n                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(key) {\n                    var output;\n                    return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n                      while (1) {\n                        switch (_context9.prev = _context9.next) {\n                          case 0:\n                            output = node.outputs[key];\n                            _context9.next = 3;\n                            return Promise.all(output.connections.map( /*#__PURE__*/function () {\n                              var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(c) {\n                                var nextNode;\n                                return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n                                  while (1) {\n                                    switch (_context8.prev = _context8.next) {\n                                      case 0:\n                                        nextNode = _this4.data.nodes[c.node];\n\n                                        if (_this4.forwarded.has(nextNode)) {\n                                          _context8.next = 7;\n                                          break;\n                                        }\n\n                                        _this4.forwarded.add(nextNode);\n\n                                        _context8.next = 5;\n                                        return _this4.processNode(nextNode);\n\n                                      case 5:\n                                        _context8.next = 7;\n                                        return _this4.forwardProcess(nextNode);\n\n                                      case 7:\n                                      case \"end\":\n                                        return _context8.stop();\n                                    }\n                                  }\n                                }, _callee8);\n                              }));\n\n                              return function (_x9) {\n                                return _ref3.apply(this, arguments);\n                              };\n                            }()));\n\n                          case 3:\n                            return _context9.abrupt(\"return\", _context9.sent);\n\n                          case 4:\n                          case \"end\":\n                            return _context9.stop();\n                        }\n                      }\n                    }, _callee9);\n                  }));\n\n                  return function (_x8) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }()));\n\n              case 4:\n                return _context10.abrupt(\"return\", _context10.sent);\n\n              case 5:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function forwardProcess(_x7) {\n        return _forwardProcess.apply(this, arguments);\n      }\n\n      return forwardProcess;\n    }()\n  }, {\n    key: \"copy\",\n    value: function copy(data) {\n      data = Object.assign({}, data);\n      data.nodes = Object.assign({}, data.nodes);\n      Object.keys(data.nodes).forEach(function (key) {\n        data.nodes[key] = Object.assign({}, data.nodes[key]);\n      });\n      return data;\n    }\n  }, {\n    key: \"validate\",\n    value: function () {\n      var _validate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(data) {\n        var checking, recursion, recurrentNode;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                checking = Validator.validate(this.id, data);\n                recursion = new Recursion(data.nodes);\n\n                if (checking.success) {\n                  _context11.next = 6;\n                  break;\n                }\n\n                _context11.next = 5;\n                return this.throwError(checking.msg);\n\n              case 5:\n                return _context11.abrupt(\"return\", _context11.sent);\n\n              case 6:\n                recurrentNode = recursion.detect();\n\n                if (!recurrentNode) {\n                  _context11.next = 11;\n                  break;\n                }\n\n                _context11.next = 10;\n                return this.throwError('Recursion detected', recurrentNode);\n\n              case 10:\n                return _context11.abrupt(\"return\", _context11.sent);\n\n              case 11:\n                return _context11.abrupt(\"return\", true);\n\n              case 12:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function validate(_x10) {\n        return _validate.apply(this, arguments);\n      }\n\n      return validate;\n    }()\n  }, {\n    key: \"processStartNode\",\n    value: function () {\n      var _processStartNode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(id) {\n        var startNode;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                if (id) {\n                  _context12.next = 2;\n                  break;\n                }\n\n                return _context12.abrupt(\"return\");\n\n              case 2:\n                startNode = this.data.nodes[id];\n\n                if (startNode) {\n                  _context12.next = 7;\n                  break;\n                }\n\n                _context12.next = 6;\n                return this.throwError('Node with such id not found');\n\n              case 6:\n                return _context12.abrupt(\"return\", _context12.sent);\n\n              case 7:\n                _context12.next = 9;\n                return this.processNode(startNode);\n\n              case 9:\n                _context12.next = 11;\n                return this.forwardProcess(startNode);\n\n              case 11:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function processStartNode(_x11) {\n        return _processStartNode.apply(this, arguments);\n      }\n\n      return processStartNode;\n    }()\n  }, {\n    key: \"processUnreachable\",\n    value: function () {\n      var _processUnreachable = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n        var data, i, node;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                data = this.data;\n                _context13.t0 = _regeneratorRuntime.keys(data.nodes);\n\n              case 2:\n                if ((_context13.t1 = _context13.t0()).done) {\n                  _context13.next = 12;\n                  break;\n                }\n\n                i = _context13.t1.value; // process nodes that have not been reached\n\n                node = data.nodes[i];\n\n                if (!(typeof node.outputData === 'undefined')) {\n                  _context13.next = 10;\n                  break;\n                }\n\n                _context13.next = 8;\n                return this.processNode(node);\n\n              case 8:\n                _context13.next = 10;\n                return this.forwardProcess(node);\n\n              case 10:\n                _context13.next = 2;\n                break;\n\n              case 12:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function processUnreachable() {\n        return _processUnreachable.apply(this, arguments);\n      }\n\n      return processUnreachable;\n    }()\n  }, {\n    key: \"process\",\n    value: function () {\n      var _process = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(data) {\n        var startId,\n            _len,\n            args,\n            _key,\n            _args14 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                startId = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : null;\n\n                if (this.processStart()) {\n                  _context14.next = 3;\n                  break;\n                }\n\n                return _context14.abrupt(\"return\");\n\n              case 3:\n                if (this.validate(data)) {\n                  _context14.next = 5;\n                  break;\n                }\n\n                return _context14.abrupt(\"return\");\n\n              case 5:\n                this.data = this.copy(data);\n\n                for (_len = _args14.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n                  args[_key - 2] = _args14[_key];\n                }\n\n                this.args = args;\n                this.forwarded = new Set();\n                _context14.next = 11;\n                return this.processStartNode(startId);\n\n              case 11:\n                _context14.next = 13;\n                return this.processUnreachable();\n\n              case 13:\n                return _context14.abrupt(\"return\", this.processDone() ? 'success' : 'aborted');\n\n              case 14:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function process(_x12) {\n        return _process.apply(this, arguments);\n      }\n\n      return process;\n    }()\n  }]);\n\n  return Engine;\n}(Context);\n\nvar index = {\n  Engine: Engine,\n  Recursion: Recursion,\n  Component: Component$1,\n  Control: Control,\n  Connection: Connection,\n  Emitter: Emitter,\n  Input: Input,\n  IO: IO,\n  Node: Node,\n  NodeEditor: NodeEditor,\n  Output: Output,\n  Socket: Socket\n};\nexport default index;\nexport { Component$1 as Component, Connection, Control, Emitter, Engine, IO, Input, Node, NodeEditor, Output, Recursion, Socket };","map":{"version":3,"sources":["../src/engine/component.ts","../src/node.ts","../src/component.ts","../src/connection.ts","../src/control.ts","../src/core/emitter.ts","../src/io.ts","../src/input.ts","../src/core/validator.ts","../src/core/context.ts","../src/view/utils.ts","../src/view/drag.ts","../src/view/zoom.ts","../src/view/area.ts","../src/view/connection.ts","../src/view/control.ts","../src/view/socket.ts","../src/view/node.ts","../src/view/index.ts","../src/selected.ts","../src/core/events.ts","../src/events.ts","../src/editor.ts","../src/output.ts","../src/socket.ts","../src/engine/recursion.ts","../src/engine/state.ts","../src/engine/events.ts","../src/engine/index.ts","../src/index.ts"],"names":["Component","Node","list","item","control","input","output","ios","connections","io","reduceIO","key","obj","name","node","json","x","y","Math","data","Connection","Control","Emitter","events","names","params","e","Array","IO","Input","multiConns","c","Validator","id1","id","id2","msg","success","Boolean","Context","plugin","options","component","window","Drag","onTranslate","onStart","onDrag","destroyMove","listenWindow","destroyUp","delta","zoom","Zoom","container","destroyCancel","rect","wheelDelta","ox","oy","touches","pointers","x1","y1","x2","y2","distance","cx","cy","p","Area","k","el","document","emitter","t","clientX","clientY","transform","source","d","ConnectionView","connection","points","ControlView","SocketView","position","NodeView","bindSocket","bindControl","s","socket","payload","accumulate","dx","dy","px","py","prev","EditorView","view","nodeView","viewInput","viewOutput","connView","width","height","Selected","Events","warn","console","error","componentregister","destroy","EditorEvents","nodecreate","nodecreated","noderemove","noderemoved","connectioncreate","connectioncreated","connectionremove","connectionremoved","translatenode","nodetranslate","nodetranslated","nodedraged","nodedragged","selectnode","multiselectnode","nodeselect","nodeselected","rendernode","rendersocket","rendercontrol","renderconnection","updateconnection","keydown","keyup","translate","translated","zoomed","click","mousemove","contextmenu","process","clear","NodeEditor","nodes","checking","Object","jsonNode","outputJson","nodeId","jsonConnection","targetOutput","targetInput","Output","Socket","array2","Recursion","nodesData","inters","intersect","inputNodes","l","inter","nodesArr","State","AVAILABLE","PROCESSED","ABORT","EngineEvents","Engine","engine","message","ret","res","a","conns","connData","prevNode","outputs","inputData","outputData","nextNode","recursion","recurrentNode","startNode","i","startId","args"],"mappings":"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","sourcesContent":["import { Engine } from './index';\nimport { NodeData, WorkerInputs, WorkerOutputs } from '../core/data';\n\nexport abstract class Component {\n\n    name: string;\n    data: unknown = {};\n    engine: Engine | null = null;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n\n    abstract worker(node: NodeData, inputs: WorkerInputs, outputs: WorkerOutputs, ...args: unknown[]): void;\n}","import { Connection } from './connection';\nimport { Control } from './control';\nimport { Input } from './input';\nimport { Output } from './output';\nimport { InputsData, NodeData, OutputsData } from './core/data';\n\nexport class Node {\n\n    name: string;\n    id: number;\n    position: [number, number] = [0.0, 0.0];\n    inputs = new Map<string, Input>();\n    outputs = new Map<string, Output>();\n    controls = new Map<string, Control>();\n    data: {[key: string]: unknown} = {};\n    meta: {[key: string]: unknown} = {};\n\n    static latestId = 0;\n    \n    constructor(name: string) {\n        this.name = name;\n        this.id = Node.incrementId();\n    }\n\n    _add<T extends any>(list: Map<string, T>, item: T, prop: string) {\n        if (list.has(item.key))\n            throw new Error(`Item with key '${item.key}' already been added to the node`);\n        if (item[prop] !== null)\n            throw new Error('Item has already been added to some node');\n        \n        item[prop] = this;\n        list.set(item.key, item);\n    }\n\n    addControl(control: Control) {\n        this._add(this.controls, control, 'parent');\n        return this;\n    }\n\n    removeControl(control: Control) {\n        control.parent = null;\n\n        this.controls.delete(control.key);\n    }\n\n    addInput(input: Input) {\n        this._add(this.inputs, input, 'node');\n        return this;\n    }\n\n    removeInput(input: Input) {\n        input.removeConnections();\n        input.node = null;\n\n        this.inputs.delete(input.key);\n    }\n\n    addOutput(output: Output) {\n        this._add(this.outputs, output, 'node');\n        return this;\n    }\n\n    removeOutput(output: Output) {\n        output.removeConnections();\n        output.node = null;\n\n        this.outputs.delete(output.key);\n    }\n\n    getConnections() {\n        const ios = [...this.inputs.values(), ...this.outputs.values()];\n        const connections = ios.reduce((arr, io) => {\n            return [...arr, ...io.connections];\n        }, [] as Connection[]);\n\n        return connections;\n    }\n\n    update() {}\n\n    static incrementId() {\n        if (!this.latestId)\n            this.latestId = 1\n        else\n            this.latestId++\n        return this.latestId\n    }\n\n    static resetId() {\n        this.latestId = 0;\n    }\n\n    toJSON(): NodeData {\n        const reduceIO = <T extends any>(list: Map<string, Input | Output>) => {\n            return Array.from(list).reduce<T>((obj, [key, io]) => {\n                obj[key] = io.toJSON();\n                return obj;\n            }, {} as any)\n        }\n\n        return {\n            'id': this.id,\n            'data': this.data,\n            'inputs': reduceIO<InputsData>(this.inputs),\n            'outputs': reduceIO<OutputsData>(this.outputs),\n            'position': this.position,\n            'name': this.name\n        }\n    }\n\n    static fromJSON(json: NodeData) {\n        const node = new Node(json.name);\n        const [x, y] = json.position;\n\n        node.id = json.id;\n        node.data = json.data;\n        node.position = [x, y];\n        node.name = json.name;\n        Node.latestId = Math.max(node.id, Node.latestId);\n\n        return node;\n    }\n}\n","import { Component as ComponentWorker } from './engine/component';\nimport { Node } from './node';\nimport { NodeEditor } from './editor';\n\nexport abstract class Component extends ComponentWorker {\n\n    editor: NodeEditor | null = null;\n    data: unknown = {};\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    abstract async builder(node: Node): Promise<void>;\n\n    async build(node: Node) {\n        await this.builder(node);\n\n        return node;\n    }\n\n    async createNode(data = {}) {\n        const node = new Node(this.name);\n        \n        node.data = data;\n        await this.build(node);\n\n        return node;\n    }\n}","import { Input } from './input';\nimport { Output } from './output';\n\nexport class Connection {\n\n    output: Output;\n    input: Input;\n    data: unknown = {};\n\n    constructor(output: Output, input: Input) {\n        this.output = output;\n        this.input = input;\n        this.data = {};\n\n        this.input.addConnection(this);\n    }\n\n    remove() {\n        this.input.removeConnection(this);\n        this.output.removeConnection(this);\n    }\n}","import { Input } from './input';\nimport { Node } from './node';\n\nexport class Control {\n\n    key: string;\n    data: unknown = {};\n    parent: Node | Input | null = null;\n\n    constructor(key: string) {\n        if (this.constructor === Control)\n            throw new TypeError('Can not construct abstract class');\n        if (!key)\n            throw new Error('The key parameter is missing in super() of Control ');\n\n        this.key = key;\n    }\n\n    getNode() {\n        if (this.parent === null)\n            throw new Error('Control isn\\'t added to Node/Input');   \n        \n        if (this.parent instanceof Node)\n            return this.parent;\n            \n        if (!this.parent.node)\n            throw new Error('Control hasn\\'t be added to Input or Node');\n\n        return this.parent.node;\n    }\n\n    getData(key: string) {\n        return this.getNode().data[key];\n    }\n\n    putData(key: string, data: unknown) {\n        this.getNode().data[key] = data;\n    }  \n}","import { Events } from './events';\n\nexport class Emitter<EventTypes> {\n\n    events: {[key: string]: Function[]} = {};\n    silent = false;\n\n    constructor(events: Events | Emitter<EventTypes>) {\n        this.events = events instanceof Emitter ? events.events : events.handlers;\n    }\n\n    on<K extends keyof EventTypes>(names: K | K[], handler: (args: EventTypes[K]) => void | unknown): this {\n        const events = names instanceof Array ? names : (names as string).split(' ');\n\n        (events as string[]).forEach(name => {\n            if (!this.events[name])\n                throw new Error(`The event ${name} does not exist`);\n            this.events[name].push(handler);\n        });\n\n        return this;\n    }\n\n    trigger<K extends keyof EventTypes>(name: K, params: EventTypes[K] | {} = {}) {\n        if (!(name in this.events))\n            throw new Error(`The event ${name} cannot be triggered`);\n\n        return this.events[name as string].reduce((r: boolean, e: Function) => {\n            return (e(params) !== false) && r\n        }, true); // return false if at least one event is false        \n    }\n\n    bind(name: string) {\n        if (this.events[name])\n            throw new Error(`The event ${name} is already bound`);\n\n        this.events[name] = [];\n    }\n\n    exist(name: string) {\n        return Array.isArray(this.events[name]);\n    }\n}","import { Connection } from './connection';\nimport { Node } from './node';\nimport { Socket } from './socket';\n\nexport class IO {\n\n    node: Node | null = null;\n    multipleConnections: boolean;\n    connections: Connection[] = [];\n   \n    key: string;\n    name: string;\n    socket: Socket;\n\n    constructor(key: string, name: string, socket: Socket, multiConns: boolean) {\n\t    this.node = null;\n        this.multipleConnections = multiConns;\n        this.connections = [];\n\t   \n        this.key = key;\n        this.name = name;\n        this.socket = socket;\n    }\n    \n    removeConnection(connection: Connection) {\n        this.connections.splice(this.connections.indexOf(connection), 1);\n    }\n\n    removeConnections() {\n        this.connections.forEach(connection => this.removeConnection(connection));\n    }\n}","import { Connection } from './connection';\nimport { Control } from './control';\nimport { IO } from './io';\nimport { InputData } from './core/data';\nimport { Socket } from './socket';\n\nexport class Input extends IO {\n   \n    control: Control | null = null;\n\n    constructor(key: string, title: string, socket: Socket, multiConns: boolean = false) {\n        super(key, title, socket, multiConns);\n    }\n\n    hasConnection() {\n        return this.connections.length > 0;\n    }\n\n    addConnection(connection: Connection) {\n        if (!this.multipleConnections && this.hasConnection())\n            throw new Error('Multiple connections not allowed');\n        this.connections.push(connection);\n    }\n\n    addControl(control: Control) {\n        this.control = control;\n        control.parent = this;\n    }\n\n    showControl() {\n        return !this.hasConnection() && this.control !== null;\n    }\n\n    toJSON(): InputData {\n        return {\n            'connections': this.connections.map(c => {\n                if (!c.output.node) throw new Error('Node not added to Output');\n\n                return {\n                    node: c.output.node.id,\n                    output: c.output.key,\n                    data: c.data\n                };\n            })\n        };\n    }\n}","import { Data } from './data';\n\nexport class Validator {\n\n    static isValidData(data: Data) {\n        return typeof data.id === 'string' &&\n            this.isValidId(data.id) &&\n            data.nodes instanceof Object && !(data.nodes instanceof Array);\n    }\n\n    static isValidId(id: string) {\n        return /^[\\w-]{3,}@[0-9]+\\.[0-9]+\\.[0-9]+$/.test(id);\n    }\n\n    static validate(id: string, data: Data) {\n        const id1 = id.split('@');\n        const id2 = data.id.split('@');\n        let msg = [];\n\n        if (!this.isValidData(data))\n            msg.push('Data is not suitable'); \n        if (id !== data.id)\n            msg.push('IDs not equal');\n        if (id1[0] !== id2[0])\n            msg.push('Names don\\'t match');\n        if (id1[1] !== id2[1])\n            msg.push('Versions don\\'t match');\n\n        return { success: Boolean(!msg.length), msg: msg.join('. ') };\n    }\n}","import { Component } from '../engine/component';\nimport { Emitter } from './emitter'\nimport { Validator } from './validator'\nimport { EventsTypes as DefaultEvents, Events } from './events';\nimport { Plugin, PluginParams } from './plugin';\n\nexport class Context<EventsTypes> extends Emitter<EventsTypes & DefaultEvents> {\n\n    id: string;\n    plugins: Map<string, unknown>;\n    components: Map<string, Component>;\n\n    constructor(id: string, events: Events) {\n        super(events);\n\n        if (!Validator.isValidId(id))\n            throw new Error('ID should be valid to name@0.1.0 format');  \n        \n        this.id = id;\n        this.plugins = new Map();\n        this.components = new Map();\n    }\n\n    use<T extends Plugin, O extends PluginParams<T>>(plugin: T, options?: O) {\n        if (plugin.name && this.plugins.has(plugin.name)) throw new Error(`Plugin ${plugin.name} already in use`)\n\n        plugin.install(this, options || {});\n        this.plugins.set(plugin.name, options)\n    }\n\n    register(component: Component) {\n        if (this.components.has(component.name))\n            throw new Error(`Component ${component.name} already registered`);\n\n        this.components.set(component.name, component);\n        this.trigger('componentregister', component);\n    }\n\n    destroy() {\n        this.trigger('destroy');\n    }\n}","export function listenWindow<K extends keyof WindowEventMap>(event: K, handler: (e: WindowEventMap[K]) => void) {\n    window.addEventListener(event, handler);\n    \n    return () => {\n        window.removeEventListener<K>(event, handler);\n    }\n}","import { listenWindow } from './utils';\n\nexport class Drag {\n\n    pointerStart: [number, number] | null;\n    el: HTMLElement;\n    destroy: () => void;\n\n    constructor(\n        el: HTMLElement,\n        private onTranslate = (_x: number, _y: number, _e: PointerEvent) => {},\n        private onStart = (_e: PointerEvent) => {},\n        private onDrag = (_e: PointerEvent) => {}\n    ) {\n        this.pointerStart = null;\n        this.el = el;\n\n        this.el.style.touchAction = 'none';\n        this.el.addEventListener('pointerdown', this.down.bind(this));\n\n        const destroyMove = listenWindow('pointermove', this.move.bind(this));\n        const destroyUp = listenWindow('pointerup', this.up.bind(this));\n\n        this.destroy = () => { destroyMove(); destroyUp(); }\n    }\n\n    down(e: PointerEvent) {\n        if ((e.pointerType === 'mouse') && (e.button !== 0)) return;\n        e.stopPropagation();\n        this.pointerStart = [e.pageX, e.pageY]\n\n        this.onStart(e);\n    }\n\n    move(e: PointerEvent) {\n        if (!this.pointerStart) return;\n        e.preventDefault();\n\n        let [x, y] = [e.pageX, e.pageY]\n\n        let delta = [x - this.pointerStart[0], y - this.pointerStart[1]];\n\n        let zoom = this.el.getBoundingClientRect().width / this.el.offsetWidth;\n\n        this.onTranslate(delta[0] / zoom, delta[1] / zoom, e);\n    }\n\n    up(e: PointerEvent) {\n        if (!this.pointerStart) return;\n        \n        this.pointerStart = null;\n        this.onDrag(e);\n    }\n}","import { listenWindow } from './utils';\n\ninterface DeltaWheelEvent { wheelDelta: number }\n\nexport class Zoom {\n\n    el: HTMLElement;\n    intensity: number;\n    onzoom: Function;\n    previous: { cx: number; cy: number; distance: number } | null = null;\n\n    pointers: PointerEvent[] = [];\n    destroy: () => void;\n\n    constructor(container: HTMLElement, el: HTMLElement, intensity: number, onzoom: Function) {\n        this.el = el;\n        this.intensity = intensity;\n        this.onzoom = onzoom;\n\n        container.addEventListener('wheel', this.wheel.bind(this));\n        container.addEventListener('pointerdown', this.down.bind(this));\n        container.addEventListener('dblclick', this.dblclick.bind(this));\n\n        const destroyMove = listenWindow('pointermove', this.move.bind(this));\n        const destroyUp = listenWindow('pointerup', this.end.bind(this));\n        const destroyCancel = listenWindow('pointercancel', this.end.bind(this));\n\n        this.destroy = () => { destroyMove(); destroyUp(); destroyCancel(); }\n    }\n\n    get translating() { // is translating while zoom (works on multitouch)\n        return this.pointers.length >= 2;\n    }\n\n    wheel(e: WheelEvent) {\n        e.preventDefault();\n        \n        const rect = this.el.getBoundingClientRect();\n        const wheelDelta = (e as unknown as DeltaWheelEvent).wheelDelta;\n        const delta = (wheelDelta ? wheelDelta / 120 : - e.deltaY / 3) * this.intensity;\n\n        const ox = (rect.left - e.clientX) * delta;\n        const oy = (rect.top - e.clientY) * delta;\n\n        this.onzoom(delta, ox, oy, 'wheel');\n    }\n\n    touches() {\n        let e = { touches: this.pointers }\n        let [x1, y1] = [e.touches[0].clientX, e.touches[0].clientY];\n        let [x2, y2] = [e.touches[1].clientX, e.touches[1].clientY];\n\n        let distance = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n\n        return {\n            cx: (x1 + x2)/2,\n            cy: (y1 + y2)/2,\n            distance\n        };\n    }\n\n    down(e: PointerEvent) {\n        this.pointers.push(e);\n    }\n\n    move(e: PointerEvent) {\n        this.pointers = this.pointers.map(p => p.pointerId === e.pointerId ? e : p)\n        if (!this.translating) return;\n\n        let rect = this.el.getBoundingClientRect();\n\n        let { cx, cy, distance } = this.touches();\n\n        if (this.previous !== null) {\n            let delta = distance / this.previous.distance - 1;\n    \n            const ox = (rect.left - cx) * delta;\n            const oy = (rect.top - cy) * delta;\n\n            this.onzoom(delta, ox - (this.previous.cx - cx), oy - (this.previous.cy - cy), 'touch');\n        }\n        this.previous = { cx, cy, distance };\n    }\n\n    end(e: PointerEvent) {\n        this.previous = null;\n        this.pointers = this.pointers.filter(p => p.pointerId !== e.pointerId)\n    }\n\n    dblclick(e: MouseEvent) {\n        e.preventDefault();\n        \n        const rect = this.el.getBoundingClientRect();\n        const delta = 4 * this.intensity;\n\n        const ox = (rect.left - e.clientX) * delta;\n        const oy = (rect.top - e.clientY) * delta;\n\n        this.onzoom(delta, ox, oy, 'dblclick'); \n    }\n}","import { Drag } from './drag';\nimport { Emitter } from '../core/emitter';\nimport { EventsTypes } from '../events';\nimport { Zoom } from './zoom';\n\nexport interface Transform { k: number; x: number; y: number }\nexport interface Mouse { x: number; y: number }\nexport type ZoomSource = 'wheel' | 'touch' | 'dblclick';\n\nexport class Area extends Emitter<EventsTypes> {\n\n    el: HTMLElement;\n    container: HTMLElement;\n    transform: Transform = { k: 1, x: 0, y: 0 };\n    mouse: Mouse = { x: 0, y: 0 }\n    \n    private _startPosition: Transform | null = null\n    private _zoom: Zoom;\n    private _drag: Drag;\n\n    constructor(container: HTMLElement, emitter: Emitter<EventsTypes>) {\n        super(emitter);\n        \n        const el = this.el = document.createElement('div');\n\n        this.container = container;\n        el.style.transformOrigin = '0 0';\n\n        this._zoom = new Zoom(container, el, 0.1, this.onZoom.bind(this));\n        this._drag = new Drag(container, this.onTranslate.bind(this), this.onStart.bind(this));\n\n        emitter.on('destroy', () => {\n            this._zoom.destroy();\n            this._drag.destroy();\n        });\n\n        this.container.addEventListener('pointermove', this.pointermove.bind(this));\n\n        this.update();\n    }\n\n    update() {\n        const t = this.transform;\n\n        this.el.style.transform = `translate(${t.x}px, ${t.y}px) scale(${t.k})`;\n    }\n\n    pointermove(e: PointerEvent) {\n        const { clientX, clientY } = e;\n        const rect = this.el.getBoundingClientRect();\n        const x = clientX - rect.left;\n        const y = clientY - rect.top;\n        const k = this.transform.k;\n        \n        this.mouse = { x: x / k, y: y / k };\n        this.trigger('mousemove', { ...this.mouse }); // TODO rename on `pointermove`\n    }\n\n    onStart() {\n        this._startPosition = { ...this.transform };\n    }\n\n    onTranslate(dx: number, dy: number) {\n        if (this._zoom.translating) return; // lock translation while zoom on multitouch\n        if (this._startPosition) this.translate(this._startPosition.x + dx, this._startPosition.y + dy);\n    }\n\n    onZoom(delta: number, ox: number, oy: number, source: ZoomSource) {\n        this.zoom(this.transform.k * (1 + delta), ox, oy, source);\n\n        this.update();\n    }\n\n    translate(x: number, y: number) {\n        const params = { transform: this.transform, x, y };\n\n        if (!this.trigger('translate', params)) return;\n\n        this.transform.x = params.x;\n        this.transform.y = params.y;\n\n        this.update();\n        this.trigger('translated');\n    }\n\n    zoom(zoom: number, ox = 0, oy = 0, source: ZoomSource) {\n        const k = this.transform.k;\n        const params = { transform: this.transform, zoom, source };\n\n        if (!this.trigger('zoom', params)) return;\n        \n        const d = (k - params.zoom) / ((k - zoom) || 1);\n\n        this.transform.k = params.zoom || 1;\n        this.transform.x += ox * d;\n        this.transform.y += oy * d;\n\n        this.update();\n        this.trigger('zoomed', { source });\n    }\n\n    appendChild(el: HTMLElement) {\n        this.el.appendChild(el)\n    }\n\n    removeChild(el: HTMLElement) {\n        this.el.removeChild(el)\n    }\n}","import { Connection } from '../connection';\nimport { Emitter } from '../core/emitter';\nimport { EventsTypes } from '../events';\nimport { NodeView } from './node';\n\nexport class ConnectionView extends Emitter<EventsTypes> {\n\n    connection: Connection;\n    inputNode: NodeView;\n    outputNode: NodeView;\n    el: HTMLElement;\n\n    constructor(connection: Connection, inputNode: NodeView, outputNode: NodeView, emitter: Emitter<EventsTypes>) {\n        super(emitter);\n        this.connection = connection;\n        this.inputNode = inputNode;\n        this.outputNode = outputNode;\n\n        this.el = document.createElement('div');\n        this.el.style.position = 'absolute';\n        this.el.style.zIndex = '-1';\n\n        this.trigger('renderconnection', { \n            el: this.el, \n            connection: this.connection, \n            points: this.getPoints()\n        });\n    }\n\n    getPoints() {\n        const [x1, y1] = this.outputNode.getSocketPosition(this.connection.output);\n        const [x2, y2] = this.inputNode.getSocketPosition(this.connection.input);\n\n        return [x1, y1, x2, y2];\n    }\n\n    update() {\n        this.trigger('updateconnection', { \n            el: this.el, \n            connection: this.connection, \n            points: this.getPoints()\n        });\n    }\n}","import { Control } from '../control';\nimport { Emitter } from '../core/emitter';\nimport { EventsTypes } from '../events';\n\nexport class ControlView extends Emitter<EventsTypes> {\n\n    constructor(el: HTMLElement, control: Control, emitter: Emitter<EventsTypes>) {\n        super(emitter);\n        this.trigger('rendercontrol', { el, control });\n    }\n}","import { Emitter } from '../core/emitter';\nimport { EventsTypes } from '../events';\nimport { IO } from '../io';\nimport { Node } from '../node';\n\nexport class SocketView extends Emitter<EventsTypes> {\n\n    el: HTMLElement;\n    type: string;\n    io: IO;\n    node: Node;\n\n    constructor(el: HTMLElement, type: string, io: IO, node: Node, emitter: Emitter<EventsTypes>) {\n        super(emitter);\n        this.el = el;\n        this.type = type;\n        this.io = io;\n        this.node = node;\n\n        this.trigger('rendersocket', { el, [type]: this.io, socket: io.socket });\n    }\n\n    getPosition({ position }: { position: number[] }): [number, number] {\n        const el = this.el;\n\n        return [\n            position[0] + el.offsetLeft + el.offsetWidth / 2,\n            position[1] + el.offsetTop + el.offsetHeight / 2\n        ]\n    }\n}","import { Component } from '../engine/component';\nimport { Control } from '../control';\nimport { ControlView } from './control';\nimport { Drag } from './drag';\nimport { Emitter } from '../core/emitter';\nimport { EventsTypes } from '../events';\nimport { IO } from '../io';\nimport { Node } from '../node';\nimport { SocketView } from './socket';\n\nexport class NodeView extends Emitter<EventsTypes> {\n\n    node: Node;\n    component: Component;\n    sockets = new Map<IO, SocketView>();\n    controls = new Map<Control, ControlView>();\n\n    el: HTMLElement;\n    private _startPosition: number[] = [];\n    private _drag: Drag;\n\n    constructor(node: Node, component: Component, emitter: Emitter<EventsTypes>) {\n        super(emitter);\n\n        this.node = node;\n        this.component = component;\n        this.el = document.createElement('div');\n        this.el.style.position = 'absolute';\n\n        this.el.addEventListener('contextmenu', e => this.trigger('contextmenu', { e, node: this.node }));\n\n        this._drag = new Drag(this.el, this.onTranslate.bind(this), this.onSelect.bind(this), () => {\n            this.trigger('nodedraged', node);\n            this.trigger('nodedragged', node);\n        });\n\n        this.trigger('rendernode', {\n            el: this.el, \n            node, \n            component: component.data, \n            bindSocket: this.bindSocket.bind(this),\n            bindControl: this.bindControl.bind(this)\n        });\n\n        this.update();\n    }\n\n    clearSockets() {\n        const ios: IO[] = [ ...this.node.inputs.values(), ...this.node.outputs.values()];\n        \n        this.sockets.forEach(s => {\n            if (!ios.includes(s.io)) this.sockets.delete(s.io);\n        });\n    }\n\n    bindSocket(el: HTMLElement, type: string, io: IO) {\n        this.clearSockets();\n        this.sockets.set(io, new SocketView(el, type, io, this.node, this));\n    }\n\n    bindControl(el: HTMLElement, control: Control) {\n        this.controls.set(control, new ControlView(el, control, this));\n    }\n\n    getSocketPosition(io: IO) {\n        const socket = this.sockets.get(io);\n\n        if (!socket) throw new Error(`Socket not found for ${io.name} with key ${io.key}`);\n\n        return socket.getPosition(this.node);\n    }\n\n    onSelect(e: MouseEvent) {\n        const payload = { node: this.node, accumulate: e.ctrlKey, e };\n    \n        this.onStart();\n        this.trigger('multiselectnode', payload);\n        this.trigger('selectnode', payload);\n    }\n\n    onStart() {\n        this._startPosition = [...this.node.position];\n    }\n\n    onTranslate(dx: number, dy: number) {\n        this.trigger('translatenode', { node: this.node, dx, dy });\n    }\n\n    onDrag(dx: number, dy: number) {\n        const x = this._startPosition[0] + dx;\n        const y = this._startPosition[1] + dy;\n\n        this.translate(x, y);\n    }\n\n    translate(x: number, y: number) {\n        const node = this.node;\n        const params = { node, x, y };\n\n        if (!this.trigger('nodetranslate', params)) return;\n\n        const [px, py] = node.position;\n        const prev: [number, number] = [px, py];\n\n        node.position[0] = params.x;\n        node.position[1] = params.y;\n\n        this.update();\n        this.trigger('nodetranslated', { node, prev });\n    }\n\n    update() {\n        const [x, y] = this.node.position;\n\n        this.el.style.transform = `translate(${x}px, ${y}px)`;\n    }\n\n    remove() {\n        \n    }\n\n    destroy() {\n        this._drag.destroy();\n    }\n}\n","import { Area } from './area';\nimport { Component } from '../engine/component';\nimport { Connection } from '../connection';\nimport { ConnectionView } from './connection';\nimport { Emitter } from '../core/emitter';\nimport { EventsTypes } from '../events';\nimport { Node } from '../node';\nimport { NodeView } from './node';\nimport { listenWindow } from './utils';\n\nexport class EditorView extends Emitter<EventsTypes> {\n\n    container: HTMLElement;\n    components: Map<string, Component>;\n    nodes = new Map<Node, NodeView>();\n    connections = new Map<Connection, ConnectionView>();\n    area: Area;\n\n    constructor(container: HTMLElement, components: Map<string, Component>, emitter: Emitter<EventsTypes>) {\n        super(emitter);\n\n        this.container = container;\n        this.components = components;\n\n        this.container.style.overflow = 'hidden';\n\n        this.container.addEventListener('click', this.click.bind(this));\n        this.container.addEventListener('contextmenu', e => this.trigger('contextmenu', { e, view: this }));\n        emitter.on('destroy', listenWindow('resize', this.resize.bind(this)));\n        emitter.on('destroy', () => this.nodes.forEach(view => view.destroy()));\n  \n        this.on('nodetranslated', this.updateConnections.bind(this));\n            \n        this.area = new Area(container, this);\n        this.container.appendChild(this.area.el);\n    }\n\n    addNode(node: Node) {\n        const component = this.components.get(node.name);\n\n        if (!component) throw new Error(`Component ${node.name} not found`);\n        \n        const nodeView = new NodeView(node, component, this);\n\n        this.nodes.set(node, nodeView);\n        this.area.appendChild(nodeView.el);\n    }\n\n    removeNode(node: Node) {\n        const nodeView = this.nodes.get(node);\n\n        this.nodes.delete(node);\n        if (nodeView) {\n            this.area.removeChild(nodeView.el);\n            nodeView.destroy();\n        }\n    }\n\n    addConnection(connection: Connection) {\n        if (!connection.input.node || !connection.output.node)\n            throw new Error('Connection input or output not added to node');\n\n        const viewInput = this.nodes.get(connection.input.node);\n        const viewOutput = this.nodes.get(connection.output.node);\n\n        if (!viewInput || !viewOutput)\n            throw new Error('View node not found for input or output');\n\n        const connView = new ConnectionView(connection, viewInput, viewOutput, this);\n\n        this.connections.set(connection, connView);\n        this.area.appendChild(connView.el);\n    }\n\n    removeConnection(connection: Connection) {\n        const connView = this.connections.get(connection);\n\n        this.connections.delete(connection);\n        if (connView)\n            this.area.removeChild(connView.el);\n    }\n\n    updateConnections({ node }: { node: Node }) {\n        node.getConnections().forEach(conn => {\n            let connView = this.connections.get(conn);\n\n            if (!connView) throw new Error('Connection view not found');\n\n            connView.update();\n        });\n    }\n\n    resize() {\n        const { container } = this;\n\n        if (!container.parentElement)\n            throw new Error('Container doesn\\'t have parent element');\n\n        const width = container.parentElement.clientWidth;\n        const height = container.parentElement.clientHeight;\n\n        container.style.width = width + 'px';\n        container.style.height = height + 'px';\n    }\n\n    click(e: Event) {\n        const container = this.container;\n        \n        if (container !== e.target) return;\n        if (!this.trigger('click', { e, container })) return;\n    }\n}\n","import { Node } from './node';\n\nexport class Selected {\n\n    list: Node[] = [];\n\n    add(item: Node, accumulate = false) {\n        if (!accumulate)\n            this.list = [item]; \n        else if (!this.contains(item))\n            this.list.push(item);   \n    }\n\n    clear() {\n        this.list = [];\n    }\n\n    remove(item: Node) {\n        this.list.splice(this.list.indexOf(item), 1);\n    }\n\n    contains(item: Node) {\n        return this.list.indexOf(item) !== -1;\n    }\n\n    each(callback: (n: Node, index: number) => void) {\n        this.list.forEach(callback);\n    }\n}","import { Component } from '../engine/component';\n\nexport class Events {\n\n    handlers: {};\n\n    constructor(handlers: {}) {\n        this.handlers = {\n            warn: [console.warn],\n            error: [console.error],\n            componentregister: [],\n            destroy: [],\n            ...handlers\n        }\n    }\n}\n\nexport interface EventsTypes {\n    warn: string | Error;\n    error: string | Error;\n    componentregister: Component;\n    destroy: void;\n}","import { Component } from './component';\nimport { Connection } from './connection';\nimport { Control } from './control';\nimport { Data } from './core/data';\nimport { EditorView } from './view';\nimport { Input } from './input';\nimport { Node } from './node';\nimport { Output } from './output';\nimport { Socket } from './socket';\nimport { EventsTypes as DefaultEventsTypes, Events } from './core/events';\nimport { Mouse, Transform, ZoomSource } from './view/area';\n\nexport class EditorEvents extends Events {\n\n    constructor() {\n        super({\n            nodecreate: [],\n            nodecreated: [],\n            noderemove: [],\n            noderemoved: [],\n            connectioncreate: [],\n            connectioncreated: [],\n            connectionremove: [],\n            connectionremoved: [],\n            translatenode: [],\n            nodetranslate: [],\n            nodetranslated: [],\n            nodedraged: [],\n            nodedragged: [],\n            selectnode: [],\n            multiselectnode: [],\n            nodeselect: [],\n            nodeselected: [],\n            rendernode: [],\n            rendersocket: [],\n            rendercontrol: [],\n            renderconnection: [],\n            updateconnection: [],\n            keydown: [],\n            keyup: [],\n            translate: [],\n            translated: [],\n            zoom: [],\n            zoomed: [],\n            click: [],\n            mousemove: [],\n            contextmenu: [],\n            import: [],\n            export: [],\n            process: [],\n            clear: []\n        });\n    }    \n}\n\nexport interface EventsTypes extends DefaultEventsTypes {\n    componentregister: Component;\n    nodecreate: Node;\n    nodecreated: Node;\n    noderemove: Node;\n    noderemoved: Node;\n    connectioncreate: { input: Input; output: Output };\n    connectioncreated: Connection;\n    connectionremove: Connection;\n    connectionremoved: Connection;\n    translatenode: { node: Node; dx: number; dy: number };\n    nodetranslate: { node: Node; x: number; y: number };\n    nodetranslated: { node: Node; prev: [number, number] };\n    nodedraged: Node;\n    nodedragged: Node;\n    selectnode: {\n        node: Node;\n        accumulate: boolean;\n    };\n    multiselectnode: {\n        node: Node;\n        accumulate: boolean;\n        e: MouseEvent;\n    };\n    nodeselect: Node;\n    nodeselected: Node;\n    rendernode: {\n        el: HTMLElement;\n        node: Node;\n        component: object;\n        bindSocket: Function;\n        bindControl: Function;\n    };\n    rendersocket: {\n        el: HTMLElement;\n        input?: Input;\n        output?: Output;\n        socket: Socket;\n    };\n    rendercontrol: {\n        el: HTMLElement;\n        control: Control;\n    };\n    renderconnection: {\n        el: HTMLElement;\n        connection: Connection;\n        points: number[];\n    };\n    updateconnection: {\n        el: HTMLElement;\n        connection: Connection;\n        points: number[];\n    };\n    keydown: KeyboardEvent;\n    keyup: KeyboardEvent;\n    translate: {\n        transform: Transform;\n        x: number;\n        y: number;\n    };\n    translated: void;\n    zoom: {\n        transform: Transform;\n        zoom: number;\n        source: ZoomSource;\n    };\n    zoomed: {\n        source: ZoomSource;\n    };\n    click: {\n        e: Event;\n        container: HTMLElement;\n    };\n    mousemove: Mouse;\n    contextmenu: {\n        e: MouseEvent;\n        view?: EditorView;\n        node?: Node;\n    };\n    import: Data;\n    export: Data;\n    process: void;\n    clear: void;\n}\n","import { Component } from './component';\nimport { Connection } from './connection';\nimport { Context } from './core/context';\nimport { Data } from './core/data';\nimport { EditorView } from './view/index';\nimport { Input } from './input';\nimport { Node } from './node';\nimport { Output } from './output';\nimport { Selected } from './selected';\nimport { Validator } from './core/validator';\nimport { listenWindow } from './view/utils';\nimport { EditorEvents, EventsTypes } from './events';\n\nexport class NodeEditor extends Context<EventsTypes> {\n\n    nodes: Node[] = [];\n    selected = new Selected();\n    view: EditorView;\n\n    constructor(id: string, container: HTMLElement) {\n        super(id, new EditorEvents());\n        \n        this.view = new EditorView(container, this.components, this);\n\n        this.on('destroy', listenWindow('keydown', e => this.trigger('keydown', e)));\n        this.on('destroy', listenWindow('keyup', e => this.trigger('keyup', e)));\n\n        this.on('selectnode', ({ node, accumulate }) => this.selectNode(node, accumulate));\n        this.on('nodeselected', () => this.selected.each(n => {\n            const nodeView = this.view.nodes.get(n);\n\n            nodeView && nodeView.onStart()\n        }));\n        this.on('translatenode', ({ dx, dy }) => this.selected.each(n => {\n            const nodeView = this.view.nodes.get(n);\n\n            nodeView && nodeView.onDrag(dx, dy)\n        }));\n    }\n\n    addNode(node: Node) {\n        if (!this.trigger('nodecreate', node)) return;\n\n        this.nodes.push(node);\n        this.view.addNode(node);\n        \n        this.trigger('nodecreated', node);\n    }\n\n    removeNode(node: Node) {\n        if (!this.trigger('noderemove', node)) return;\n\n        node.getConnections().forEach(c => this.removeConnection(c));\n\n        this.nodes.splice(this.nodes.indexOf(node), 1);\n        this.view.removeNode(node);\n\n        this.trigger('noderemoved', node);\n    }\n\n    connect(output: Output, input: Input, data: unknown = {}) {\n        if (!this.trigger('connectioncreate', { output, input })) return;\n\n        try {\n            const connection = output.connectTo(input);\n\n            connection.data = data;\n            this.view.addConnection(connection);\n\n            this.trigger('connectioncreated', connection);\n        } catch (e) {\n            this.trigger('warn', e)\n        }\n    }\n\n    removeConnection(connection: Connection) {\n        if (!this.trigger('connectionremove', connection)) return;\n            \n        this.view.removeConnection(connection);\n        connection.remove();\n\n        this.trigger('connectionremoved', connection);\n    }\n\n    selectNode(node: Node, accumulate: boolean = false) {\n        if (this.nodes.indexOf(node) === -1) \n            throw new Error('Node not exist in list');\n        \n        if (!this.trigger('nodeselect', node)) return;\n\n        this.selected.add(node, accumulate);\n        \n        this.trigger('nodeselected', node);\n    }\n\n    getComponent(name: string) {\n        const component = this.components.get(name);\n\n        if (!component)\n            throw `Component ${name} not found`;\n        \n        return component as Component;\n    }\n\n    register(component: Component) {\n        super.register(component)\n        component.editor = this;\n    }\n\n    clear() {\n        [...this.nodes].forEach(node => this.removeNode(node));\n        this.trigger('clear');\n    }\n\n    toJSON() {\n        const data: Data = { id: this.id, nodes: {} };\n        \n        this.nodes.forEach(node => data.nodes[node.id] = node.toJSON());\n        this.trigger('export', data);\n        return data;\n    }\n\n    beforeImport(json: Data) {\n        const checking = Validator.validate(this.id, json);\n        \n        if (!checking.success) {\n            this.trigger('warn', checking.msg);\n            return false;\n        }\n        \n        this.silent = true;\n        this.clear();\n        this.trigger('import', json);\n        return true;\n    }\n\n    afterImport() {\n        this.silent = false;\n        return true;\n    }\n\n    async fromJSON(json: Data) {\n        if (!this.beforeImport(json)) return false;\n        const nodes: {[key: string]: Node} = {};\n\n        try {\n            await Promise.all(Object.keys(json.nodes).map(async id => {\n                const node = json.nodes[id];\n                const component = this.getComponent(node.name);\n\n                nodes[id] = await component.build(Node.fromJSON(node));\n                this.addNode(nodes[id]);\n            }));\n        \n            Object.keys(json.nodes).forEach(id => {\n                const jsonNode = json.nodes[id];\n                const node = nodes[id];\n                \n                Object.keys(jsonNode.outputs).forEach(key => {\n                    const outputJson = jsonNode.outputs[key];\n\n                    outputJson.connections.forEach(jsonConnection => {\n                        const nodeId = jsonConnection.node;\n                        const data = jsonConnection.data;\n                        const targetOutput = node.outputs.get(key);\n                        const targetInput = nodes[nodeId].inputs.get(jsonConnection.input);\n\n                        if (!targetOutput || !targetInput) {\n                            return this.trigger('error', `IO not found for node ${node.id}`);\n                        }\n\n                        this.connect(targetOutput, targetInput, data);\n                    });\n                });\n\n            });\n        } catch (e) {\n            this.trigger('warn', e);\n            return !this.afterImport();\n        }\n\n        return this.afterImport();\n    }\n}\n","import { Connection } from './connection';\nimport { IO } from './io';\nimport { Input } from './input';\nimport { OutputData } from './core/data';\nimport { Socket } from './socket';\n\nexport class Output extends IO {\n  \n    constructor(key: string, title: string, socket: Socket, multiConns: boolean = true) {\n        super(key, title, socket, multiConns);\n    }\n    \n    hasConnection() {\n        return this.connections.length > 0;\n    }\n\n    connectTo(input: Input) {\n        if (!this.socket.compatibleWith(input.socket))\n            throw new Error('Sockets not compatible');\n        if (!input.multipleConnections && input.hasConnection())\n            throw new Error('Input already has one connection');\n        if (!this.multipleConnections && this.hasConnection())\n            throw new Error('Output already has one connection');\n\n        const connection = new Connection(this, input);\n\n        this.connections.push(connection);\n        return connection;\n    }\n\n    connectedTo(input: Input) {\n        return this.connections.some((item) => {\n            return item.input === input;\n        });\n    }\n\n    toJSON(): OutputData {\n        return {\n            'connections': this.connections.map(c => {\n                if (!c.input.node) throw new Error('Node not added to Input');\n\n                return {\n                    node: c.input.node.id,\n                    input: c.input.key,\n                    data: c.data\n                }\n            })\n        };\n    }\n}","export class Socket {\n\n    name: string;\n    data: unknown;\n    compatible: Socket[] = [];\n\n    constructor(name: string, data = {}) {\n        this.name = name;\n        this.data = data;\n        this.compatible = [];\n    }\n\n    combineWith(socket: Socket) {\n        this.compatible.push(socket);\n    }\n\n    compatibleWith(socket: Socket) {\n        return this === socket || this.compatible.includes(socket);\n    }\n}","import { InputConnectionData, NodeData, NodesData } from '../core/data';\n\nfunction intersect<T>(array1: T[], array2: T[]) {\n    return array1.filter(value => -1 !== array2.indexOf(value));\n}\n\nexport class Recursion {\n\n    nodes: NodesData;\n\n    constructor(nodes: NodesData) {\n        this.nodes = nodes;\n    }\n    \n    extractInputNodes(node: NodeData): NodeData[] {\n        return Object.keys(node.inputs).reduce((acc: NodeData[], key: string) => {\n            const { connections } = node.inputs[key];\n            const nodesData = (connections || []).reduce((b: NodeData[], c: InputConnectionData) => {\n                return [...b, this.nodes[c.node]];\n            }, []);\n\n            return [...acc, ...nodesData]\n        }, []);\n    }\n\n    findSelf(list: NodeData[], inputNodes: NodeData[]): NodeData | null {\n        const inters = intersect<NodeData>(list, inputNodes);\n\n        if (inters.length)\n            return inters[0];\n        \n        for (let node of inputNodes) {\n            let l = [node, ...list];\n            let inter = this.findSelf(l, this.extractInputNodes(node));\n\n            if (inter)\n                return inter;\n        }\n\n        return null;\n    }\n\n    detect(): NodeData | null {\n        const nodesArr = Object.keys(this.nodes).map(id => this.nodes[id]);\n\n        for (let node of nodesArr) {\n            let inters = this.findSelf([node], this.extractInputNodes(node));\n\n            if (inters)\n                return inters;\n        }\n\n        return null;\n    }\n}","export const State = { AVAILABLE: 0, PROCESSED: 1, ABORT: 2 }","import { Events } from '../core/events';\n\nexport class EngineEvents extends Events {\n\n    constructor() {\n        super({});\n    }    \n}\nexport interface EventsTypes {\n}","import { Component } from './component';\nimport { Context } from '../core/context';\nimport { Recursion } from './recursion';\nimport { State } from './state';\nimport { Validator } from '../core/validator';\nimport { Data, NodeData, WorkerOutputs } from '../core/data';\nimport { EngineEvents, EventsTypes } from './events';\nexport { Component, Recursion };\n\ninterface EngineNode extends NodeData {\n    busy: boolean;\n    unlockPool: (() => void)[];\n    outputData: WorkerOutputs;\n}\n\nexport class Engine extends Context<EventsTypes> {\n\n    args: unknown[] = [];\n    data: Data | null = null;\n    state = State.AVAILABLE;\n    forwarded = new Set();\n    onAbort = () => { };\n\n    constructor(id: string) {\n        super(id, new EngineEvents());\n    }\n\n    public clone() {\n        const engine = new Engine(this.id);\n\n        this.components.forEach(c => engine.register(c));\n\n        return engine;\n    }\n\n    async throwError (message: string, data: unknown = null) {\n        await this.abort();\n        this.trigger('error', { message, data });\n        this.processDone();\n\n        return 'error';\n    }\n\n    private processStart() {\n        if (this.state === State.AVAILABLE) {  \n            this.state = State.PROCESSED;\n            return true;\n        }\n\n        if (this.state === State.ABORT) {\n            return false;\n        }\n\n        console.warn(`The process is busy and has not been restarted.\n                Use abort() to force it to complete`);\n        return false;\n    }\n\n    private processDone() {\n        const success = this.state !== State.ABORT;\n\n        this.state = State.AVAILABLE;\n        \n        if (!success) {\n            this.onAbort();\n            this.onAbort = () => { }\n        }    \n\n        return success;\n    }\n\n    public async abort() {\n        return new Promise(ret => {\n            if (this.state === State.PROCESSED) {\n                this.state = State.ABORT;\n                this.onAbort = ret;\n            }\n            else if (this.state === State.ABORT) {\n                this.onAbort();\n                this.onAbort = ret;\n            }\n            else\n                ret();\n        });\n    }\n\n    private async lock(node: EngineNode) {\n        return new Promise(res => {\n            node.unlockPool = node.unlockPool || [];\n            if (node.busy && !node.outputData)\n                node.unlockPool.push(res);\n            else \n                res();\n            \n            node.busy = true;\n        });    \n    }\n\n    unlock(node: EngineNode) {\n        node.unlockPool.forEach(a => a());\n        node.unlockPool = [];\n        node.busy = false;\n    }\n\n    private async extractInputData(node: NodeData) {\n        const obj: {[id: string]: any} = {};\n\n        for (let key of Object.keys(node.inputs)) {\n            const input = node.inputs[key];\n            const conns = input.connections;\n            const connData = await Promise.all(conns.map(async (c) => {\n                const prevNode = (this.data as Data).nodes[c.node];\n\n                const outputs = await this.processNode(prevNode as EngineNode);\n\n                if (!outputs) \n                    this.abort();\n                else\n                    return outputs[c.output];\n            }));\n\n            obj[key] = connData;\n        }\n\n        return obj;\n    }\n\n    private async processWorker(node: NodeData) {\n        const inputData = await this.extractInputData(node);\n        const component = this.components.get(node.name) as Component;\n        const outputData = {};\n\n        try {\n            await component.worker(node, inputData, outputData, ...this.args);\n        } catch (e) {\n            this.abort();\n            this.trigger('warn', e);\n        }\n\n        return outputData;\n    }\n\n    private async processNode(node: EngineNode) {\n        if (this.state === State.ABORT || !node)\n            return null;\n        \n        await this.lock(node);\n\n        if (!node.outputData) {\n            node.outputData = await this.processWorker(node);\n        }\n\n        this.unlock(node);\n        return node.outputData;\n    }\n\n    private async forwardProcess(node: NodeData) {\n        if (this.state === State.ABORT)\n            return null;\n        \n        return await Promise.all(Object.keys(node.outputs).map(async (key) => {\n            const output = node.outputs[key];\n            return await Promise.all(output.connections.map(async (c) => {\n                const nextNode = (this.data as Data).nodes[c.node];\n                if(!this.forwarded.has(nextNode)) {\n                    this.forwarded.add(nextNode);\n                    await this.processNode(nextNode as EngineNode);\n                    await this.forwardProcess(nextNode);\n                }\n            }));\n        }));\n    }\n\n    copy(data: Data) {\n        data = Object.assign({}, data);\n        data.nodes = Object.assign({}, data.nodes);\n        \n        Object.keys(data.nodes).forEach(key => {\n            data.nodes[key] = Object.assign({}, data.nodes[key])\n        });\n        return data;\n    }\n\n    async validate(data: Data) {\n        const checking = Validator.validate(this.id, data);\n        const recursion = new Recursion(data.nodes);\n\n        if (!checking.success)\n            return await this.throwError(checking.msg);  \n        \n        const recurrentNode = recursion.detect();\n\n        if (recurrentNode)\n            return await this.throwError('Recursion detected', recurrentNode);      \n         \n        return true;\n    }\n\n    private async processStartNode(id: string | number | null) {\n        if (!id) return;\n\n        let startNode = (this.data as Data).nodes[id];\n\n        if (!startNode)\n            return await this.throwError('Node with such id not found');   \n        \n        await this.processNode(startNode as EngineNode);\n        await this.forwardProcess(startNode);\n    }\n\n    private async processUnreachable() {\n        const data = this.data as Data;\n\n        for (let i in data.nodes) { // process nodes that have not been reached\n            const node = data.nodes[i] as EngineNode;\n\n            if (typeof node.outputData === 'undefined') {\n                await this.processNode(node);\n                await this.forwardProcess(node);\n            }\n        }\n    }\n\n    async process<T extends unknown[]>(data: Data, startId: number | string | null = null, ...args: T) {\n        if (!this.processStart()) return;\n        if (!this.validate(data)) return;    \n        \n        this.data = this.copy(data);\n        this.args = args;\n        this.forwarded = new Set();\n        \n        await this.processStartNode(startId);\n        await this.processUnreachable();\n        \n        return this.processDone()?'success':'aborted';\n    }\n}\n","import { Component } from './component';\nimport { Connection } from './connection';\nimport { Control } from './control';\nimport { Emitter } from './core/emitter';\nimport { IO } from './io';\nimport { Input } from './input';\nimport { Node } from './node';\nimport { NodeEditor } from './editor';\nimport { Output } from './output';\nimport { Socket } from './socket';\nimport { Engine, Recursion } from './engine/index';\n\nexport { Engine, Recursion } from './engine/index';\nexport { Component } from './component';\nexport { Control } from './control';\nexport { Connection } from './connection';\nexport { Emitter } from './core/emitter';\nexport { Input } from './input';\nexport { IO } from './io';\nexport { Node } from './node';\nexport { NodeEditor } from './editor';\nexport { Output } from './output';\nexport { Socket } from './socket';\n\nexport default {\n    Engine,\n    Recursion,\n    Component,\n    Control,\n    Connection,\n    Emitter,\n    Input,\n    IO,\n    Node,\n    NodeEditor,\n    Output,\n    Socket\n}"]},"metadata":{},"sourceType":"module"}